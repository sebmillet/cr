= Cryptographie pratique
:asciimath:
:toc:
:toclevels: 3
:numbered:
:imagesdir: ./images

== Introduction

Cet article décrit les calculs à réaliser pour vérifier des signatures RSA et ECDSA, dans le cas des certificats x509. Ces certificats sont couramment utilisés et servent notamment à la sécurisation https.

* _RSA_{nbsp}: ce cas sera traité avec le certificat d'un serveur https.
* _ECDSA_{nbsp}: nous commencerons par travailler sur un certificat auto-signé que nous créerons pour l'occasion, afin de se familiariser avec les calculs qu'implique la cryptographie à courbes elliptiques. Pour finir nous récupérerons un certificat CEV (Certificat Électronique Visible). Ce dernier cas sort du cadre x509 qui est l'objet principal de cet article, le format pour un tel certificat étant 2D-Doc.

Au fil du document nous ferons appel aux outils suivants{nbsp}:

* `openssl` pour travailler sur les certificats x509 en ligne de commande
* `python`, `bc` ou `zsbc` pour faire des calculs avec des nombres entiers de grande taille
* Conversion entre encodage _PEM_ et encodage _binaire_ (Linux{nbsp}: `base64`, Windows{nbsp}: `notepad`++)
* Édition du contenu de fichier binaire (Linux{nbsp}: `gvim/xxd`, Windows{nbsp}: `notepad`++)

[NOTE]
.Windows versus Linux
======================================
Ce document s'adresse aux utilisateurs de Windows et Linux.

Il peut arriver qu'entre les deux environnements l'outil ou la commande à employer soit différente. Dans ce cas la solution pour chaque système est présentée.
======================================

<<<

== Le format x509

=== Visualisation d'un certificat x509

A l'aide d'un navigateur, ouvrir une page en https et afficher le certificat.
Les exemples de ce document sont réalisés avec le certificat https du site https://letsencrypt.org/.

.Exemple avec Firefox 44

. Cliquer sur l'icône de cadenas à gauche de la barre d'adresse et cliquer sur la flèche droite (figure 1)
. Cliquer sur _Plus d'informations_ (figure 2)
. Cliquer sur _Afficher le certificat_ (figure 3)
. Afficher l'onglet _Détails_ et parcourir les différents champs du certificat (figures 4, 5, 6)

.Fig. 1
image:img-firefox-1-redim.png["Image Firefox 1"]

.Fig. 2
image:img-firefox-2-redim.png["Image Firefox 2"]

.Fig. 3
image:img-firefox-3-redim.png["Image Firefox 3"]

.Fig. 4
image:img-firefox-4-redim.png["Image Firefox 4"]

.Fig. 5
image:img-firefox-5-redim.png["Image Firefox 5"]

.Fig. 6
image:img-firefox-6-redim.png["Image Firefox 6"]

Nous nous intéresserons à la partie supérieure (_Hiérarchie des certificats_) plus tard.

Pour le moment examinons le certificat. L'affichage de Firefox en dessous de _Champs du certificat_ liste trois parties{nbsp}:

. Le certificat proprement dit, qui contient beaucoup d'informations structurées sur plusieurs niveaux hiérarchiques
. L'algorithme de signature du certificat, dans notre exemple, _PKCS #1 SHA-256 avec chiffrement RSA_
. La signature du certificat, ici, une suite de 256 octets

Cette structure en trois parties est toujours respectée pour un certificat x509.
A noter qu'Internet Explorer et Chrome affichent les mêmes informations mais sans faire ressortir la structure trois parties.

=== Structure d'un certificat x509

Où la structure d'un certificat est-elle définie, et quelle est cette définition ?

Une recherche sur un moteur de recherche avec les mots-clés _RFC_ et _x509_ produit l'URL suivante dans les premières réponses{nbsp}:

https://tools.ietf.org/html/rfc5280

Et effectivement lafootnote:[Nous utiliserons le féminin dans ce document. RFC étant un acronyme anglais, il n'y a pas d'argument définitif pour l'emploi du masculin ou du féminin.]
*RFC 5280* définit le format x509 version 3.

Affichons-la. Dans la section _4.1_ se trouve la définition suivante.

----
...
4.1.  Basic Certificate Fields

   The X.509 v3 certificate basic syntax is as follows.  For signature
   calculation, the data that is to be signed is encoded using the ASN.1
   distinguished encoding rules (DER) [X.690].  ASN.1 DER encoding is a
   tag, length, value encoding system for each element.

Certificate  ::=  SEQUENCE  {
	tbsCertificate       TBSCertificate,
	signatureAlgorithm   AlgorithmIdentifier,
	signatureValue       BIT STRING  }
...
----

La suite définit les différents éléments du certificat, à savoir ce que sont les structures _TBSCertificate_ et _AlgorithmIdentifier_.

.Grammaire, ASN.1 et DER
****
La structure du certificat est décrite par une _grammaire_, d'après les règles de syntaxe *ASN.1* (**A**bstrat **S**yntax **N**otation number **1**){nbsp}<<1>>.

Les différents encodages possibles du standard _ASN.1_ sont eux-mêmes des standards et le *X.690* est l'un d'entre eux{nbsp}<<2>>.

La RFC précise que la partie du certificat à signer doit être encodée selon le standard _Distinguished Encoding Rules_ ou *DER*. Entre autres encodages, le document X.690 définit le DER.

Nous verrons plus loin l'encodage DER.
Si vous souhaitez le découvrir, plutôt que d'examiner directement le document X.690, je vous recommande de commencer par l'article Wikipédia{nbsp}<<3>>.
****

En ASN.1 le mot-clé _SEQUENCE_ sans autre précision indique que la valeur est constituée d'une suite de valeurs elles-mêmes spécifiées en ASN.1. La valeur _Certificate_ contient donc, à la suite{nbsp}:

. La valeur _tbsCertificate_, soit le certificat à signer (**t**o **b**e **s**igned *Certificate*)
. La valeur _signatureAlgorithm_, soit l'identification de l'algorithme de signature
. La valeur _signatureValue_, soit la signature elle-même

=== Hiérarchie des certificats

Dans la partie tbsCertificate de _letsencrypt.org_, intéressons-nous à deux éléments en particulier, l'_émetteur_ du certificat et le _sujet_ du certificat.

* Le _sujet_ du certificat a pour *CN* (**C**ommon **N**ame) letsencrypt.org et c'est le dernier nom qui est affiché dans la hiérarchie des certificats (partie supérieure de la fenêtre).
* L'_émetteur_ du certificat a pour CN _TrustID Server CA A52_ et on peut voir ce nom au-dessus de letsencrypt.org dans la hiérarchie.

L'émetteur et le sujet ont également le pays (**C**) et l'organisation (**O**) définis dans leur nom, ainsi que d'autres éléments.
Le "nom simple" ou "nom court" du certificat est son CN. Le standard x509 ne définit pas cette notion de "nom simple" ou "nom court", nous l'employons ici pour préciser que dans la pratique, le CN est le véritable nom du certificat, les autres éléments donnant des informations annexes.
Parfois, seul le CN est affiché pour désigner un certificat.

Cela dit, le nom du certificat (au sens du standard x509) est constitué de _la totlité des éléments qui le composent_, et non pas seulement du CN.

Le lien hiérarchique est toujours établi entre un émetteur et un sujet.
L'émetteur est celui qui signe le certificat, le sujet est celui qui est signé. Voir figures 7 et 8.

Un certificat peut être à la fois émetteur (d'autres certificats sont signés par lui) et sujet (il est lui-même signé par un autre certificat), et cette chaîne forme une structure hiérarchique.
Dans notre exemple, on voit que le certificat _TrustID Server CA A52_ est lui-même signé par _IdenTrust Commercial Root CA 1_.

[NOTE]
Dans la pratique la situation se complique souvent avec des certificats croisés. Quoi qu'il en soit, la structure de base des liens qui relient les certificats est hiérarchique.

.Fig. 7{nbsp}: Sujet du certificat
image:img-crt-1-redim.png["Image certificat : sujet"]

.Fig. 8{nbsp}: Émetteur du certificat
image:img-crt-2-redim.png["Image certificat : émetteur"]

Pour signer, l'émetteur utilise sa clé privée. La vérification de la signature est faite avec sa clé publique.
Ainsi pour vérifier l'authenticité du certificat https de _letsencrypt.org_, nous aurons besoin de la clé publique de son émetteur, _TrustID Server CA A52_.

Ce principe est toujours respecté avec les certificats x509, que ce soit avec RSA ou d'autres mécanismes à clé publique / clé privée.

Nous allons maintenant passer à la vérification de la signature RSA.

<<<

== Vérification de signature RSA

=== La signature RSA

.Notations
****
* La valeur à signer (ou si l'on préfère, le _bloc de données_ à signer) est *tbsCertificate*, soit le certificat sans les informations de signature. Dans la structure en trois parties de notre certificat x509, c'est la première.
* L'entité qui signe le certificat (l'émetteur du certificat) a pour clé RSA *(n, e)* (**n** est le modulo, **e** est l'exposant) et **d**.
Le couple *(n, e)* est la clé publique, **d** est la clé privée.

La page Wikipédia consacrée au système RSA{nbsp}<<4>> explique le lien entre _(n, e)_ et _d_, et nous indique le calcul à effectuer pour _chiffrer_.
Pour _signer_, le calcul inverse le rôle de l'exposant privé et public, et pour _vérifier_ la signature, le rôle des exposants privé et public est encore inversé (par rapport à la signature).

Dans notre exemple le tbsCertificate est celui de _letsencrypt.org_, tandis que la clé RSA (clé publique _(n, e)_ et clé privée _d_) est celle de _TrustID Server CA A52_.
****

==== Calcul de la signature

. L'émetteur calcule le hash (noté _M_) de la valeur _tbsCertificate_ du sujet, soit asciimath:[M=hash("tbsCertificate")]
. Il calcule la signature (notée _S_) avec la formule asciimath:[S \equiv M^d ("mod " n)]
footnote:[On simplifie ici pour se concentrer sur les étapes importantes. En fait, le hash _M_ calculé n'est pas signé tel quel, il subit auparavant quelques transformations comme nous le verrons plus loin.]
footnote:[Ce calcul est le même que pour déchiffrer un message destiné au propriétaire de la clé publique (qui est ici l'émetteur du certificat). Signer en RSA revient à chiffrer en inversant le rôle de l'exposant public et privé.]

==== Vérification de la signature

. Le vérificateur calcule asciimath:[M \equiv S^e ("mod " n)]
. Il calcule asciimath:[M'=hash("tbsCertificate")]
. Si on a l'égalité asciimath:[M=M'], la signature est vérifiée

=== Vérification du certificat de letsencrypto.org

==== Choix d'un programme de calcul

Nous avons besoin d'une "calculatrice" qui calcule sur des nombres entiers arbitrairement grands, sans perte de précision. Dans la suite de ce document, c'est _bc_ qui sera utilisé{nbsp}<<5>>.

* Linux{nbsp}: _bc_ est disponible par défaut sur la plupart des distributions.
* Windows{nbsp}: les binaires sont accessibles à l'URL <<6>>.

[NOTE]
.Le choix de bc
======================================
* _bc_ est installé par défaut sur la plupart des distributions Linux, et facile et rapide à installer sous Windows.
* _bc_ contient peu de fonctions mathématiques intégrées mais sur Internet on trouve de nombreux scripts qui permettent de l'enrichir considérablement.
** Dans _bc_ la variable _scale_ définit le nombre de décimales des nombres manipulés. Comme nous ne ferons que des calculs sur des entiers, nous laisserons _scale_ à zéro (pas de partie décimale). Zéro est la valeur par défaut de _scale_ au lancement de _bc_
footnote:[Lorsque _bc_ est lancé avec l'option *_-l_*, des fonctions mathématiques sont chargées au démarrage et _scale_ vaut 20. Nous ne nous servirons pas de cette option dans ce document et _scale_ sera toujours égal à zéro.]
.
======================================

[NOTE]
.Alternatives à bc
======================================
* *sagemath*, logiciel mathématique en licence GPL.
* *python*, langage de programmation en licence GPL, calcule par défaut sur des entiers de taille arbitrairement grande et convient donc aux calculs que nous allons faire.
* Logiciels mathématiques propriétaires bien connus.
======================================

.Comparaison entre _bc_ et _python_
[options="header"]
|=====================================
^|bc ^|python
2+^|Saisie d'un entier en hexadécimal
|Exécuter au préalable

*`ibase = 2 * 8`* footnoteref:[ibase16, _2 * 8_ produit toujours 16 (décimal). Si _ibase = 16_ est exécuté alors qu'ibase vaut déjà 16, le résultat sera lu en hexadécimal et vaudra 22.]

Exemple{nbsp}:

*`ibase = 2 * 8`*

*`var = ABEF0E0`*

_(Attention les caractères hexadécimaux doivent être en majuscule.)_

|Saisir l'entier précédé de _0x_

Exemple{nbsp}:

*`>>> var = 0xabef0e0`*
footnote:[_python_ peut lire les nombres hexadécimaux indifféremment en majuscule et minuscule. _bc_ exige des majuscules.]

2+^|Affichage d'entier en hexadécimal
|Exécuter au préalable

*`obase = 2 * 8`*
footnoteref:[ibase16]

Exemple{nbsp}:

*`obase = 2 * 8`*

*`2 ^ (2 ^ 4) + 1`*
footnote:[Sous Windows, _bc_ a des difficultés à lire le caractère _circonflexe_ au clavier (en-dessous de la touche **9**). Pour contourner ce problème, il est possible d'utiliser (sur un clavier français) l'accent circonflexe à droite de la touche **P**, en appuyant dessus à deux reprises. Cela affiche deux _circonflexes_ et vous devez alors en supprimer un.]

`10001`

|Interpoler avec _%x_

Exemple{nbsp}:

*`>>> '%x' % (2 ** (2 ** 4) + 1)`*

`'10001'`
|=====================================

==== Enregistrement de la signature sous forme d'entier

. Depuis le navigateur, afficher la signature du certificat de _letsencrypt.org_.
. Sélectionner la signature et la copier-coller dans un éditeur de texte.
. Supprimer les caractère surnuméraires (enlever les ':' et les sauts de ligne).

. Passer les caractères hexadécimaux en majuscule footnote:[Si vous utilisez _python_, il est inutile de passer les caractères hexadécimaux en majuscule.].

. Ajouter _s=_ devant le nombre, et ajouter une première ligne _ibase = 2 * 8_.
. Enregistrer dans *_val.b_*.

Voir figures 9 et 10.

.Fig. 9{nbsp}: Signature dans le navigateur
image:img-cle-1-redim.png["Image signature dans navigateur"]

.Fig. 10{nbsp}: Fichier val.b
image:img-cle-2-redim.png["Image signature dans éditeur"]

L'instruction _ibase = 2 * 8_ ordonne à bc de lire les nombres en hexadécimal.
_ibase = 16_ fonctionne aussi, à condition qu'ibase soit égal à 10 (valeur par défaut) au moment d'exécuter _ibase = 16_.
Si ibase est déjà égal à 16 et que l'on exécute _ibase = 16_, une erreur se produit car bc lit 16 en hexadécimal (soit 22) et cette valeur est interdite.

[NOTE]
======================================
. Avec _bc_ il est impératif de passer les nombres hexadécimaux en majuscule.

. _bc_ n'accepte pas les noms de variable qui contiennent des majuscules.
======================================

Le navigateur affiche l'exposant de la clé RSA (le nombre noté _e_ tout à l'heure) sous forme décimale, alors que dans le script bc nous l'entrons en hexadécimal. Pour convertir un nombre décimal en hexadécimal, exécuter dans un terminal{nbsp}:

.Linux
[caption=""]
====
----
\$ echo "obase=16; 65537" | bc
10001
----
====

.Windows
[caption=""]
====
----
\$ echo obase=16; 65537 | bc.exe
10001
----
====

.Passer du texte en majuscule
****

.Linux
[caption=""]
====
Sous Linux, on peut utiliser la ligne de commande, par exemple (nombreuses autres solutions){nbsp}:
----
\$ tr '[:lower:]' '[:upper:]' < fichier_entrée > fichier_sortie
----

Un éditeur suffisamment avancé comme _vim_ ou _emacs_ le permet aussi.
====

.Windows
[caption=""]
====
Windows ne dispose pas par défaut d'outil pour passer du texte en majuscule. Il faut installer _GNUWin32_ ou _cygwin_.

L'éditeur de texte (natif) adéquat pour ce type de transformation est *_notepad++_*, disponible à cette URL <<7>>.

[NOTE]
_vim_ et _emacs_ sont disponibles sous Windows.
====
****

==== Enregistrement de la clé publique sous forme d'entier

Depuis le navigateur{nbsp}:

. Sélectionner le certificat de _TrustID Server CA A52_ et afficher sa clé publique.
. Sélectionner la valeur de la clé publique et la copier-coller dans *_val.b_*.
Il faut le faire en deux fois, une fois pour le modulo de 256 octets (variable _n_) et une fois pour l'exposant (variable _e_).

Ne pas oublier de passer les caractères hexadécimaux en majuscule.

.Clé publique dans le navigateur
image:img-cle-3-redim.png["Image clé dans navigateur"]

A l'arrivée, *_val.b_* contient trois variables, s, n et e.

.val.b
----
ibase=2*8

s=8049A7CE9627701FC4E520876B97271A8AEF34D13A5ECA776172BD7C9053DBEF9C8504E4C85629135D934D1F9C6FB09375189812B3475D5F0797F5D32BC9B11B12BC29733DCD40E57EB97BC819F21939764A4F2A270036906BAE5FD280D68DCC16428C0FCD3D213025BCFA10A6697529ED1A168E0D2CEFCB24A9C9A64C85F0BF8942B91F2CD1E92989F73EF9F2267BAB5535C3388C10C3C1D55DBC3A50A01A77CEDED612862D83A9B1A68A08B68DC35BE0F2E23E3BD9AFD4C0BA1537CFD694A5AF5D6CF8887861A9DCB89B9DE35AD3F255C251B0ECD54C2CF693DD5732EDF33939334BDB1E64C29636E0502E57914984BDA74C7E05AC948403D2BEBE051452F8

n=9769D7999885023FE9264276E8F4733FA932442690782E78579119A05D762B49F9935A5D5ACE82F3C2D8E54C367A2B1D0DDBA6A7FE91127CED7201B78CA1C5DACC9DFE09FB57E214470FE89E918F942D8032939303F5287868BA7E0F42B4317A0514225333E4A3AD6C8FAFBE636BB2329FD917B9C9E0607C99D631E1E4A0B73FAFB232AC7E8C9CDC02EBE1BC1F149CBC91F7B2FB42F3E1202BCBBF8FF3B37063FAF7752802ABC5D4B0EDEA257F87CD371496833C40021BA09E19477FF3B0CCC52560B83512F151EB17DCFC5BA5D99BEF404CD77771E9FB458B7EF2E369B042661746903ACD463DF1B0096FDCFFEE3361CAFCC72E3CED5E0AD1BF221269804B23

e=10001

----

==== La fonction powmod

Les amateurs de _python_ ont encore un avantage à ce stade. L'équivalent de la fonction _powmod_ y est disponible sous forme d'un troisième paramètre (facultatif) à la fonction _pow_.

Pour ceux qui utilisent bc comme moi, il faut écrire la fonction.

La fonction _powmod_ met en oeuvre l'algorithme d'exponentiation rapide, décrit à cette URL <<8>>.
En fait nous sommes dans un contexte modulaire et d'après Wikipédia le nom exact de l'algorithme est _exponentiation modulaire_. Un article y est consacrée <<9>>.
Les deux algorithmes font appel au même principe, mais le second exploite le contexte modulaire pour que les nombres manipulés n'atteignent pas une taille démesurée. C'est le second algorithme (_exponentiation modulaire_) dont nous avons besoin pour la suite.

Sur Internet, on peut trouver la fonction _powmod_ dans de nombreux scripts _bc_ à télécharger. À noter qu'elle porte parfois d'autres noms, _mpower_ par exemple.

.powmod.b
----
include::powmod.b[]
----

==== Calcul de _M_

Nous voilà prêts pour calculer _M_.

. Lancer la commande suivante footnote:[Par défaut, _bc_ ajoute un anti-slash après le 68e caractère et passe à la ligne suivante. On peut modifier ce comportement avec la variable d'environnement _BC_LINE_LENGTH_. Quand cette variable est égale à zéro, les nombres ne sont pas coupés.]{nbsp}:
----
\$ BC_LINE_LENGTH=0 bc powmod.b val.b
----
[start=2]
. Dans le shell _bc_, exécuter
footnoteref:[ibase16] (pour que les nombres soient affichés en hexadécimal)
----
obase=2*8
----
[start=3]
. Toujours dans le shell _bc_, exécuter
----
powmod(s, e, n)
----

Rappelons que c'est _S_ (variable _s_ dans _val.b_) qui doit être élevé à la puissance _e_, modulo _n_.
Lors de la définition d'obase, ibase vaut 16 (résultat du script _val.b_ chargé au démarrage) donc obase=16 ne fonctionnerait pas.

.Fig. 11{nbsp}: Calcul pour vérifier la signature RSA
image:img-powmod-redim.png["Image résultat powmod"]

[IMPORTANT]
Au démarrage de bc, ibase est égal à 16 du fait du chargement de _val.b_. Si vous exécutez obase = 16, obase sera égal à... 22 !
C'est logique, puisque 16 est saisi en hexadécimal. Le plus simple est d'utiliser _2{nbsp} * {nbsp}8_ comme indiqué. Vous pouvez aussi exécuter _obase = 10_ (ibase étant égal à 16), mais c'est moins clair, et vous devez être certain qu'ibase vaut bien 16 au moment d'exécuter _obase = 10_, pour passer l'affichage des nombres en hexadécimal
(_2 * 8_ fonctionne toujours quelle que soit la valeur d'ibase, y compris pour les valeurs inférieures ou égales à 7).

Le résultat (figure 11) avec tous ces _F_ prouve avec une quasi certitude que le calcul s'est bien passé.
Les _F_ correspondent au 'padding' standard effectué pour une signature RSA, la valeur qui suit (à partir de *`303130`*) est le hash de tbsCertificate "emballé".

"Emballé", c'est-à-dire ? La valeur est spécifiée en ASN.1 et codée en DER, et elle contient d'autres informations que le seul hash de tbsCertificate.

C'est ce que nous allons voir dans le chapitre suivant.

==== Analyse de _M_

Nous allons procéder en trois étapes{nbsp}:

. Enregistrement du contenu hexadécimal
. Conversion du contenu hexadécimal en binaire
. Examen du contenu binaire avec la commande _openssl asn1parse_

===== 1 Enregistrement du contenu hexadécimal

Faisons un copier-coller de _M_ (en hexadécimal) à partir de l'octet qui suit l'octet nul, et enregistrons le résultat dans le fichier *_m.hex_*.

.m.hex
image:img-m.hex-redim.png["Image m.hex"]

.Contenu de m.hex
----
include::m.hex[]
----

===== 2 Conversion du contenu hexadécimal en binaire

Maintenant nous allons convertir _m.hex_ en binaire, puisque le contenu actuel est le _codage des octets en hexadécimal_ de la signature, ce n'est pas la signature elle-même.

.Linux
[caption=""]
====
Exécuter la commande
----
\$ xxd -r -p m.hex > m.der
----
====

.Windows
[caption=""]
====
Le plus simple est d'utiliser _notepad++_ et d'enregistrer le fichier transformé avec le nom _m.der_.

.Avant
image:img-notepadpp-1-redim.png["Image notepad++ 1"]

.Après (on a enregistré le contenu binaire sous le nouveau nom *m.der*)
image:img-notepadpp-2-redim.png["Image notepad++ 2"]

[CAUTION]
[caption="Attention"]
======================================
Ne pas laisser un saut de ligne à la fin du fichier qui s'ajouterait aux données binaires de la signature.
======================================
====

Le fichier _m.der_ contient les octets que l'on avait dans la signature, ce que l'on peut vérifier facilement...

* ... sous Linux avec la commande _hd_ (on peut aussi utiliser _hexdump_ ou _xxd_).
* ... sous Windows avec _notepad++_, en reconvertissant en hexadécimal et en vérifiant que l'on retombe sur ses pieds.

.Contenu du fichier binaire m.der
image:img-m.der-redim.png["Image m.der"]

===== 3 Examen du contenu DER du fichier m.der

.openssl
****
Pour afficher le contenu binaire (qui se trouve être encodé en DER) nous allons utiliser l'exécutable en ligne de commande fourni avec la librairie openssl. Cet outil s'appelle _openssl_.

Par la suite nous utiliserons également _dder_ et _pkfile_, deux utilitaires créés par l'auteur de cet article pour afficher et extraire plus facilement ce type de données.

_dder_ est disponible à l'URL <<10>>.

_pkfile_ est disponible à l'URL <<11>>.

.Exécutable openssl

* Sous Linux ce programme est disponible par défaut.
* Sous Windows il faut trouver un binaire à télécharger.
Le plus simple est de télécharger la version GNUWin32, disponible à cette URL <<12>>.
+
La version proposée au téléchargement (en février 2016) date de 2008. Des binaires plus récents sont disponibles sur Internet.
Pour faire les manipulations décrites dans ce document, la version de GNUWin32 est suffisante.
+
** À noter que Sous Windows les environnements "de taille importante" (_cygwin_, _perl_, ...) sont souvent installés avec leur librairie openssl, qui contient l'outil en ligne de commande _openssl_.
****

Exécuter la commande
----
\$ openssl asn1parse -inform der -in m.der
----

.Fig. 12
image:img-m.der-openssl-redim.png["Image m.der avec openssl"]

Nous verrons dans le chapitre suivant la syntaxe ASN.1 plus en détail.

Sur la figure 12 _openssl_ nous donne deux informations{nbsp}:

* L'algorithme de hash est SHA-256, ce que l'on savait déjà d'après le contenu de _signatureAlgorithm_ (deuxième partie de la structure en trois parties du certificat).
* Nous voyons la valeur du hash (le bloc _prim: OCTET STRING_) sous forme hexadécimale. Sa longueur correspond bien au SHA-256 (256 bits de longueur soit 32 octets).

Nous savons désormais que la signature SHA-256 de la valeur tbsCertificate du certificat de _letsencrypt.org_ devrait être{nbsp}:
----
8364DA78F1FD8DCC6812E568268BF2DAF8791BE383109745388879C496A8C3DD
----

C'est ce que nous allons vérifier en calculant maintenant _M'_.

==== Calcul de _M'_

Nous allons calculer M' en deux étapes{nbsp}:

. Extraction de tbsCertificate du certificat _letsencrypt.org_.
. Calcul du hash SHA-256 de tbsCertificate.

Mais avant d'extraire tbsCertificate, nous devons comprendre comment le certificat est structuré et codé.

===== ASN.1 et DER

Au début de ce document, nous avons observé que la section 4.1 de la RFC 5280, qui définit la structure des certificats x509 v3, contient cette définition{nbsp}:

--------------------------------------
Certificate  ::=  SEQUENCE  {
	tbsCertificate       TBSCertificate,
	signatureAlgorithm   AlgorithmIdentifier,
	signatureValue       BIT STRING  }
--------------------------------------

Un certificat x509 est défini selon la syntaxe ASN.1.
L'encodage peut être BER
footnote:[BER signifie **B**asic **E**ncoding **R**ules]
, CER
footnote:[CER signifie **C**anonical **E**ncoding **R**ules]
ou DER
footnote:[DER signifie **D**istinguished **E**ncoding **R**ules]
.

Ces trois standards sont très proches, l'intérêt de DER étant son unicité{nbsp}: une structure de données spécifiée en ASN.1 ne peut être encodée en DER que d'une manière, et une seule. BER et CER permettent certaines variations dans la manière d'encoder.

Pour ne pas alourdir la rédaction, nous parlerons toujours d'encodage DER ou simplement DER, même lorsque les données manipulées pourraient ne pas être DER
footnote:[La RFC 5280 indique que les _données signées_ d'un certificat (la partie tbsCertificate) doivent être encodées en DER, mais ne donne pas d'indication pour le reste.]
.

ASN.1 structure chaque valeur (_data value_ dans le document X.690) selon la typologie **T**{nbsp}-{nbsp}**L**{nbsp}-{nbsp}**V** ou **T**ag{nbsp}-{nbsp}**L**ength{nbsp}-{nbsp}**V**alue.
La forme "longueur indéfinie" apporte un quatrième élément, "end-of-contents" (marqueur de fin de valeur), que nous ignorerons car DER ne permet pas cette forme.

[**T**]ag::
Définit toutes les caractéristiques de la valeur, notamment son _type_, par exemple une date (_UTCTime_), une séquence (_SEQUENCE_ ou _SEQUENCE OF_), un entier (_INTEGER_), et bien d'autres. Il définit également si l'encodage de la valeur est _primitive_ ou _contructed_.
Encodage _primitive_:::
La donnée ne contient pas de sous-structure
Encodage _constructed_:::
La donnée est elle-même une structure qui suit la typologie **T**-**L**-**V**, et ici, cette structure est elle-même définie en ASN.1
footnote:[Certains types de données, notamment les _*string_ (OCTET STRING, UTF8String, etc.), peuvent être _primitive_ ou _constructed_, ce qui signifie que leur encodage peut suivre une structure hiérarchique "propre à l'encodage", non explicitée dans la définition de la valeur en ASN.1.].
Structure hiérarchique:::
La différence _primitive_ - _constructed_ est à la base de la structure hiérarchique d'une spécification ASN.1, les éléments _constructed_ étant les branches, les éléments _primitive_ étant les feuilles.
+
Dans la définition d'un _Certificate_ ci-dessus, le type _SEQUENCE_ est, par définition du type _SEQUENCE_ en ASN.1, _constructed_. Cela signifie que la valeur _SEQUENCE_ est elle-même une structure ASN.1, ce qu'on peut voir dans la liste des trois composants d'un certificat définie entre accolades.

[**L**]ength::
Donne la longueur de la valeur en octets.

[**V**]alue::
Est la donnée elle-même. Dans ce document nous employons le terme _valeur_ (dans le document X.690 le terme est _data value_).


Affichons le contenu DER avec l'utilitaire en ligne de commande _dder_ en exécutant la commande suivante{nbsp}:
----
\$ dder -width 8 -recursive "|  " m.der
----

.Fig. 13
image:img-dder-redim.png["Image lecture m.der avec dder"]

La copie d'écran de la figure 12 a été faite sous Windows pour changer un peu.

La description de la valeur indique _-cons_ ou _-prim_, pour _constructed_ ou _primitive_.
Chaque fois que le tag indique une valeur _constructed_ (ici, il s'agit à deux reprises du type _SEQUENCE_, qui est obligatoirement _constructed_), on descend d'un niveau dans la structure hiérarchique, que l'on a fait ressortir ici avec l'option _-recursive "|  "_.

===== Extraction de tbsCertificate du certificat _letsencrypt.org_

===== Étape 1 de l'extraction
Commençons par enregistrer le certificat depuis le navigateur, dans le fichier _letsencryptorg.der_.

.Firefox
[caption=""]
====
Afficher le certificat comme vu précédemment, puis afficher l'onglet _Détails_ et cliquer sur le bouton _Exporter_.
Ensuite sélectionner _Certificat X.509 (DER)_

.Fig. 14
image:img-certsave-ff-redim.png["Enregistrement certificat depuis Firefox"]
====

.Internet Explorer et Chrome
[caption=""]
====
Afficher le certificat, puis cliquer sur le bouton _Copier dans un fichier..._. Ensuite sélectionner _X.509 binaire encodé DER_

.Fig. 15
image:img-certsave-ie-redim.png["Enregistrement certificat depuis IE et Chrome"]
====

[NOTE]
.PEM versus DER
======================================
Avec les certificats x509, l'encodage PEM est une surcouche de DER qui consiste à{nbsp}:

* Encoder le contenu binaire (après chiffrement éventuel) en BASE64
* Ajouter au début et à la fin un texte standardisé qui définit et délimite la nature du contenu, ainsi que les informations de chiffrement s'il y a lieu
** La ligne ajoutée au début commence par *`-----BEGIN`*
** La ligne ajoutée à la fin commence par *`-----END`*

Si vous avez enregistré le certificat avec un encodage PEM, vous pouvez le convertir en DER avec _openssl_. Exemple pour _letsencrypt.cer_ (PEM) que l'on convertit en _letsencrypt.der_ (DER){nbsp} - comme on peut voir, l'encodage par défaut avec _openssl_ est PEM.
----
\$ openssl x509 -in letsencryptorg.cer -outform der -out letsencryptorg.der
----

.Fig. 16
image:img-pem-redim.png["Exemple encodage PEM"]

.Fig. 17
image:img-convpemder-redim.png["Exemple conversion PEM vers DER"]

Vous pouvez faire cette conversion "à la main" en enlevant la première et la dernière ligne et en faisant une conversion BASE64{nbsp}->{nbsp}binaire avec des outils comme _base64_ (Linux) ou _notepad++_ (Windows).
======================================

===== Étape 2 de l'extraction
Nous disposons maintenant d'un certificat enregistré en binaire (encodage DER) dans le fichier _letsencryptorg.der_, dont nous allons à présent extraire la partie tbsCertificate.

[NOTE]
======================================
Les outils _dder_ et _pkfile_ (_pkfile_ est présenté plus loin) peuvent lire indifféremment des fichiers codés en PEM ou en DER. Si le fichier est PEM, il est décodé à la volée.
======================================

Il y a deux solutions pour ce faire

. À la main
. À l'aide de l'utilitaire _pkfile_. _pkfile_ est disponible à cette URL <<11>>.

.Extraction de tbsCertificate{nbsp}: alernative 1 (à la main)

Un éditeur de fichier binaire ferait l'affaire, mais la manipulation est plus claire si l'on affiche le contenu hexadécimal avec _dder_.

Exécuter la commande
----
\$ dder -recursive "|  " -hex letsencryptorg.der > d
----

[NOTE]
.Encodage des fichiers affichés par dder
======================================
_dder_ lit indifféremment des fichiers PEM et DER. Si le fichier est PEM il décode (et décrypte si nécessaire) les données en mémoire avant d'afficher le contenu DER.

Donc la commande aurait pu être (avec le fichier _letsencryptorg.cer_ encodé en PEM){nbsp}:
----
\$ dder -recursive "|  " -hex letsencryptorg.cer > d
----
======================================

Ouvrir le fichier _d_ dans un éditeur de texte.
Comme on a affiché le contenu avec un décalage à chaque niveau hiérarchique (option _-recursive "|  "_), la structure en trois parties des certificats x509 ressort bien.

Supprimer les deux premières lignes et un certain nombre de lignes à la fin pour que seul demeure le contenu de tbsCertificate. Ci-dessous, le texte à conserver est le texte sélectionné (les lignes au milieu ont été supprimées pour condenser l'image).

.Fig. 18
image:img-extracttbs-alt1-1.png["Image extraction tbsCertificate alternative 1 - 1"]

.Fig. 19
image:img-extracttbs-alt1-2-redim.png["Image extraction tbsCertificate alternative 1 - 2"]

Ensuite{nbsp}:

* Supprimer les "|" en début de ligne
* Supprimer l'offset (numéro sur six caractères)
* Supprimer le texte après les codes hexadécimaux (une fois supprimé les "|" et l'offset en début de ligne, ce sont tous les caractères au-delà de la 55e position qu'il faut supprimer).
* Supprimer tous les espaces

.Fig. 20
image:img-extracttbs-alt1-3-redim.png["Image extraction tbsCertificate alternative 1 - 3"]

On retrouve (figure 20) une sous-partie du fichier _letsencryptorg.der_, codée en hexadécimal, qui commence par *`308205ea`* et se termine par *`2e6f7267`*.

[NOTE]
======================================
Cette manipulation peut être faite avec un programme d'édition de fichier binaire, en ne gardant que les données à partir de l'offset 4, d'une longueur de 1518 octets.
======================================

Il faut ensuite convertir le contenu "codé hexadécimal" en binaire comme cela a été vu précédemment (commande _xxd -r -p_ sous Linux, avec _notepad++_ sous Windows).

Au final on obtient le fichier _tbs.der_ comme montré sur la figure 21.

.Fig. 21
image:img-extracttbs-alt1-4-redim.png["Image extraction tbsCertificate alternative 1 - 4"]

.Extraction de tbsCertificate{nbsp}: alernative 2 (à l'aide de _pkfile_)

Exécuter la commande
----
\$ pkfile letsencryptorg.der -l 2
----

.Fig. 22
image:img-extracttbs-alt2-1-redim.png["Image extraction tbsCertificate alternative 2 - 1"]

Le résultat visible sur la figure 22 nous montre que le tbsCertificate correspond à la valeur _SEQUENCE_ de 1518 octets (4 octets d'en-tête, 1514 octets de données). _pkfile_ donne à cette valeur les coordonnées 1.1.

Nous enregistrons cette valeur en binaire dans le fichier _tbs2.der_ en exécutant la commande
----
\$ pkfile letsencryptorg.der -n 1.1 -x -o tbs2.der
----

.Fig. 23
image:img-extracttbs-alt2-2.png["Image extraction tbsCertificate alternative 2 - 2"]

[NOTE]
.Encodage des fichiers analysés par pkfile
======================================
_pkfile_ lit indifféremment des fichiers PEM et DER. Si le fichier est PEM il décode (et décrypte si nécessaire) les données en mémoire avant de traiter le contenu DER.
======================================

===== Calcul du hash de tbsCertificate

.Linux
[caption=""]
====
Le calcul des différents algorithmes de hash est disponible en ligne de commande. Pour SHA-256 le programme est _sha256sum_.

Exécuter
----
\$ sha256sum tbs.der
----

.Fig. 20
image:img-calchash-1-redim.png["Calcul hash Linux"]
====

.Windows
[caption=""]
====
Lels outils de calcul de hash ne sont pas disponibles par défaut. Voici quelques solutions (d'autres existent){nbsp}:

* Utiliser _pkfile_, qui permet de calculer différents hash
footnote:[_pkfile_ peut le faire aussi sous Linux, mais dans ce système il est plus logique d'utiliser les programmes déjà installés. La fonctionnalité de calcul de hash a été ajoutée à _pkfile_ pour simplifier les manipulations sous Windows.]
.
* Installer les outils _GNUWin32_, disponibles à cette URL{nbsp}<<12>>.
* 7-ZIP ajoute des menus contextuels dans l'explorateur pour calculer différents hashs, dont SHA-256. 7-ZIP est disponible à cette URL{nbsp}<<13>>.

Exemple avec _pkfile_, exécuter
----
\$ pkfile --sha256 tbs.der
----

.Fig 21
image:img-calchash-2.png["Calcul hash Windows, 2"]

.Fig 22
image:img-calchash-3.png["Calcul hash Windows, 3"]
====

Les captures d'écran montrent également le calcul sur le fichier _tbs2.der_ (créé avec _pkfile_), qui est ben identique à _tbs.der_, ce qui confirme au passage l'équivalence des deux termes de l'alternative pour extraire tbsCertificate.

**Le hash trouvé (_M'_) concorde avec la signature (_M_), ce qui valide la signature du certificat _letsencrypt.org_**

=== Conclusion

Nous arrivons au terme des manipulations à effectuer pour vérifier la signature RSA d'un certificat x509. Les calculs étaient élémentaires, mais cela nous a permis de voir{nbsp}:

* Les différents formats et encodages et les outils pour passer de l'un à l'autre
** PEM versus DER
** BASE64 versus binaire
** Hexadécimal versus binaire
** ASN.1
** La structure de certificat x509
* Les solutions pour calculer sur des entiers de grande taille
** _python_ (évoqué ici mais non détaillé) et _bc_
** Les transformations éventuelles et précautions à prendre pour calculer en saisie et affichage hexadécimal
** La création de la fonction _powmod_ dans _bc_
* Outils divers
** Calcul du hash d'un fichier
** Extraction d'une valeur d'un fichier encodé en DER

La _signature_ a été vérifiée mais le certificat lui-même n'a pas été validé en totalité. Il y a deux raisons à cela.

. Une fois un certificat vérifié, il faut vérifier son parent dans la hiérarchie (le certificat qui l'a signé), et ainsi de suite, jusqu'à vérifier un certificat connu dans la base des certificats du navigateur (les certificats _racine_).
. Le navigateur vérifie si les certificats rencontrés ont été révoqués à l'aide des Listes de Révocation des Certificats ou _CRL_ (_**C**ertificate **R**evocation **L**ist_).


== Bibliography

* *[[[1]]]* Présentation de l'ASN.1{nbsp}: http://www.itu.int/en/ITU-T/asn1/Pages/introduction.aspx
* *[[[2]]]* Document X.690 (format PDF){nbsp}: https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
* *[[[3]]]* Article Wikipédia consacré au X.690{nbsp}: https://en.wikipedia.org/wiki/X.690
* *[[[4]]]* Article Wikipédia consacré au RSA{nbsp}: https://fr.wikipedia.org/wiki/Chiffrement_RSA
* *[[[5]]]* Page d'accueil de _bc_{nbsp}: https://www.gnu.org/software/bc/
* *[[[6]]]* _bc_ pour Windows{nbsp}: http://gnuwin32.sourceforge.net/packages/bc.htm
+
_bc_ a besoin du fichier _readline5.dll_ pour s'exécuter. Vous pouvez le trouver à cette URL{nbsp}: http://gnuwin32.sourceforge.net/packages/readline.htm

* *[[[7]]]* Le site de notepad++ {nbsp}: https://notepad-plus-plus.org/fr
* *[[[8]]]* Article Wikipédia sur l'algorithme d'exponentiation rapide{nbsp}: https://fr.wikipedia.org/wiki/Exponentiation_rapide
* *[[[9]]]* Article Wikipédia sur l'exponentiation modulaire{nbsp}: https://fr.wikipedia.org/wiki/Exponentiation_modulaire
* *[[[10]]]* Obtenir _dder_{nbsp}: http://dder.sourceforge.net
* *[[[11]]]* Obtenir _pkfile_{nbsp}: http://pkfile.sourceforge.net
* *[[[12]]]* GNUWin32{nbsp}: http://gnuwin32.sourceforge.net/packages/openssl.htm
* *[[[13]]]* Télécharger 7-ZIP{nbsp}: http://www.7-zip.org/download.html

