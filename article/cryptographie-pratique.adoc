// cryptographie-pratique.adoc
// Sébastien Millet, February 2016

= Cryptographie pratique
:author: Sébastien Millet
:email: <milletseb@laposte.net>
:revnumber: 0.5
:revdate: February 29th, 2016
:toc:
:toclevels: 3
:numbered:
:imagesdir: ./images
:source-highlighter: highlightjs

== Introduction

Cet article décrit les calculs à réaliser pour vérifier des signatures RSA et ECDSA, dans le cas des certificats x509. Ces certificats sont couramment utilisés et servent notamment à la sécurisation https.

* _RSA_{nbsp}: ce cas sera traité avec le certificat d'un serveur https.
* _ECDSA_{nbsp}: nous commencerons par travailler sur un certificat auto-signé que nous créerons pour l'occasion, afin de se familiariser avec les calculs qu'implique la cryptographie à courbes elliptiques. Pour finir nous récupérerons un certificat CEV (_**C**ertificat **É**lectronique **V**isible_) footnote:[Ce dernier cas sort du cadre x509.]

Au fil du document nous ferons appel aux outils suivants{nbsp}:

* _openssl_ pour travailler sur les certificats x509 en ligne de commande
* _pkfile_ pour extraire la partie signée d'un certificat et _dder_ pour afficher certains contenus binaires
* _python_ ou _bc_ pour faire des calculs avec des nombres entiers de grande taille
* Conversion entre encodage _PEM_ et encodage _binaire_ (Linux{nbsp}: _base64_, Windows{nbsp}: _notepad++_)
* Édition de contenu de fichier binaire (Linux{nbsp}: _gvim/xxd_, Windows{nbsp}: _notepad++_)

[NOTE]
.Windows versus Linux
======================================
Ce document s'adresse aux utilisateurs de Windows et Linux.

Il peut arriver qu'entre les deux environnements l'outil ou la commande à employer soit différente. Dans ce cas la solution pour chaque système est présentée.
======================================

<<<

== Le format x509

=== Visualisation d'un certificat x509

A l'aide d'un navigateur, ouvrir une page en https et afficher le certificat.
Les exemples de ce document sont réalisés avec le certificat https du site https://letsencrypt.org/.

.Exemple avec Firefox 44

. Cliquer sur l'icône de cadenas à gauche de la barre d'adresse et cliquer sur la flèche droite (Figure 1)
. Cliquer sur _Plus d'informations_ (Figure 2)
. Cliquer sur _Afficher le certificat_ (Figure 3)
. Afficher l'onglet _Détails_ et parcourir les différents champs du certificat (Figure 4, 5 et 6)

[caption="Fig. 1", title=" "]
image::img-firefox-1-redim.png["Image Firefox 1"]

[caption="Fig. 2", title=" "]
image::img-firefox-2-redim.png["Image Firefox 2"]

[caption="Fig. 3", title=" "]
image::img-firefox-3-redim.png["Image Firefox 3"]

[caption="Fig. 4", title=" "]
image::img-firefox-4-redim.png["Image Firefox 4"]

[caption="Fig. 5", title=" "]
image::img-firefox-5-redim.png["Image Firefox 5"]

[caption="Fig. 6", title=" "]
image::img-firefox-6-redim.png["Image Firefox 6"]

Nous nous intéresserons à la partie supérieure (_Hiérarchie des certificats_) plus tard.

Pour le moment examinons le certificat. L'affichage de Firefox en dessous de _Champs du certificat_ liste trois parties{nbsp}:

. Le certificat proprement dit, qui contient beaucoup d'informations structurées sur plusieurs niveaux hiérarchiques
. L'algorithme de signature du certificat, dans notre exemple, _PKCS #1 SHA-256 avec chiffrement RSA_
. La signature du certificat, ici, une suite de 256 octets

Cette structure en trois parties est toujours respectée pour un certificat x509.
A noter qu'Internet Explorer et Chrome affichent les mêmes informations mais sans faire ressortir la structure trois parties.

=== Structure d'un certificat x509

Où la structure d'un certificat est-elle définie, et quelle est cette définition ?

Une recherche sur un moteur de recherche avec les mots-clés _RFC_ et _x509_ produit l'URL suivante dans les premières réponses{nbsp}:

https://tools.ietf.org/html/rfc5280

Et effectivement lafootnote:[Nous utiliserons le féminin dans ce document. RFC étant un acronyme anglais, il n'y a pas d'argument définitif pour l'emploi du masculin ou du féminin.]
*RFC 5280* définit le format x509 version 3.

Affichons-la. Dans la section _4.1_ se trouve la définition suivante.

----
...
4.1.  Basic Certificate Fields

   The X.509 v3 certificate basic syntax is as follows.  For signature
   calculation, the data that is to be signed is encoded using the ASN.1
   distinguished encoding rules (DER) [X.690].  ASN.1 DER encoding is a
   tag, length, value encoding system for each element.

Certificate  ::=  SEQUENCE  {
	tbsCertificate       TBSCertificate,
	signatureAlgorithm   AlgorithmIdentifier,
	signatureValue       BIT STRING  }
...
----

La suite définit les différents éléments du certificat, à savoir ce que sont les structures _TBSCertificate_ et _AlgorithmIdentifier_.

.Grammaire, ASN.1 et DER
****
La structure du certificat est décrite par une _grammaire_, d'après les règles de syntaxe *ASN.1* (**A**bstrat **S**yntax **N**otation number **1**){nbsp}<<1>>.

Les différents encodages possibles du standard _ASN.1_ sont eux-mêmes des standards et le *X.690* est l'un d'entre eux{nbsp}<<2>>.

La RFC précise que la partie du certificat à signer doit être encodée selon le standard _Distinguished Encoding Rules_ ou *DER*. Entre autres encodages, le document X.690 définit le DER.

Nous verrons plus loin l'encodage DER.
Si vous souhaitez le découvrir, plutôt que d'examiner directement le document X.690, je vous recommande de commencer par l'article Wikipédia{nbsp}<<3>>.
****

En ASN.1 le mot-clé _SEQUENCE_ sans autre précision indique que la valeur est constituée d'une suite de valeurs elles-mêmes spécifiées en ASN.1. La valeur _Certificate_ contient donc, à la suite{nbsp}:

. La valeur _tbsCertificate_, soit le certificat à signer (**t**o **b**e **s**igned *Certificate*)
. La valeur _signatureAlgorithm_, soit l'identification de l'algorithme de signature
. La valeur _signatureValue_, soit la signature elle-même

=== Hiérarchie des certificats

Dans la partie tbsCertificate de _letsencrypt.org_, intéressons-nous à deux éléments en particulier, l'_émetteur_ du certificat et le _sujet_ du certificat.

* Le _sujet_ du certificat a pour *CN* (**C**ommon **N**ame) letsencrypt.org et c'est le dernier nom qui est affiché dans la hiérarchie des certificats (partie supérieure de la fenêtre).
* L'_émetteur_ du certificat a pour CN _TrustID Server CA A52_ et on peut voir ce nom au-dessus de letsencrypt.org dans la hiérarchie.

L'émetteur et le sujet ont également le pays (**C**) et l'organisation (**O**) définis dans leur nom, ainsi que d'autres éléments.
Le "nom simple" ou "nom court" du certificat est son CN. Le standard x509 ne définit pas cette notion de "nom simple" ou "nom court", nous l'employons ici pour préciser que dans la pratique, le CN est le véritable nom du certificat, les autres éléments donnant des informations annexes.

Cela dit, le nom (au sens du standard x509) est constitué du DN (_**D**istinguished **N**ame_), il s'agit de la _la totalité des éléments qui le composent_ (et non pas seulement le CN).

Le lien hiérarchique est toujours établi entre un émetteur et un sujet.
L'émetteur est celui qui signe le certificat, le sujet est celui qui est signé. Voir figures 7 et 8.

Un certificat peut être à la fois émetteur (d'autres certificats sont signés par lui) et sujet (il est lui-même signé par un autre certificat), et cette chaîne forme une structure hiérarchique.
Dans notre exemple, on voit que le certificat _TrustID Server CA A52_ est lui-même signé par _IdenTrust Commercial Root CA 1_.

[NOTE]
Dans la pratique la situation peut se compliquer avec des certificats croisés. Quoi qu'il en soit, la structure de base des liens qui relient les certificats est hiérarchique.

.Quelques précisions
****
* Pour qu'un certificat joue le rôle émetteur, il doit être une autorité de certification ou CA (_**C**ertificate **A**uthority_), il s'agit de l'une des nombreuses options que l'on peut trouver dans un certificat.
* En plus des éléments permettant d'identifier le sujet du certificat, la partie tbsCertificate contient sa _clé publique_. C'est précisément le rôle du certificat{nbsp}: _certifier_ la correspondance entre une entité (un DN) et une clé publique.
* L'émetteur (qui est une autorité de certification) a toujours un numéro d'identification de clé (_Subject Key Identifier_). Cet identifiant, qui doit être par construction un entier, doit être enregistré dans les certificats émis comme numéro de clé d'autorité de certification (_Authority Key Identifier_). Cette logique permet de gérer facilement les cas où une autorité de certification possède plusieurs clés.
** En résumé, quand un émetteur signe un sujet, on doit avoir égalité entre ces différents éléments
+
[options="header", cols="4,1,4"]
|====
^|Dans le certificat émetteur ^|Lien ^|Dans le certificat sujet
|Subject DN
footnote:[Ici on a un peu simplifié les choses pour ne pas alourdir le texte. En fait l'émetteur est identifié par son DN mais aussi par un _Serial Number_, nécessaire dans les cas où une même entité (DN) est associée à différentes clés. Donc le lien hiérarchique est établi avec le couple (DN, Serial Number), qui correspond à un couple (DN, key) de manière unique. Le DN seul ne serait pas suffisant. Les identifiants de clé correspondent (de manière bi-univoque) à un couple (DN, key).]
^|=
|Issuer DN
|Subject Key Identifier
^|=
|Authority Key Identifier
|====
** La RFC 5280 (<<4>>) impose l'emploi d'identifiants de clé lors de l'émission de certificats mais la section _4.2.1.2_ indique aussi que les applications ne sont pas obligées de vérifier les identifiants de clé lors de la validation d'une chaîne de certification. Conclusion{nbsp}? Il n'y en a pas.
****

[caption="Fig. 7 : Sujet du certificat", title=" "]
image::img-crt-1-redim.png["Image certificat : sujet"]

[caption="Fig. 8 : Émetteur du certificat", title=" "]
image::img-crt-2-redim.png["Image certificat : émetteur"]

Pour signer, l'émetteur utilise sa clé privée. La vérification de la signature est faite avec sa clé publique.
Ainsi pour vérifier l'authenticité du certificat https de _letsencrypt.org_, nous aurons besoin de la clé publique de son émetteur, _TrustID Server CA A52_.

Ce principe est toujours respecté avec les certificats x509, que ce soit avec RSA ou d'autres mécanismes à clé publique / clé privée.

Nous allons maintenant passer à la vérification de la signature RSA.

<<<

== Vérification de signature RSA

=== La signature RSA

.Notations
****
* La valeur à signer (ou si l'on préfère, le _bloc de données_ à signer) est *tbsCertificate*, soit le certificat sans les informations de signature. Dans la structure en trois parties de notre certificat x509, c'est la première.
* L'entité qui signe le certificat (l'émetteur du certificat) a pour clé RSA *(n, e)* (**n** est le modulo, **e** est l'exposant) et **d**.
Le couple *(n, e)* est la clé publique, **d** est la clé privée.

La page Wikipédia consacrée au système RSA{nbsp}<<5>> explique le lien entre _(n, e)_ et _d_, et nous indique le calcul à effectuer pour _chiffrer_.
Pour _signer_, le calcul inverse le rôle de l'exposant privé et public, et pour _vérifier_ la signature, le rôle des exposants privé et public est encore inversé (par rapport à la signature).

Dans notre exemple le tbsCertificate est celui de _letsencrypt.org_, tandis que la clé RSA (clé publique _(n, e)_ et clé privée _d_) est celle de _TrustID Server CA A52_.
****

==== Calcul de la signature

. L'émetteur calcule le hash (noté _M_) de la valeur _tbsCertificate_ du sujet, soit _M{nbsp}={nbsp}hash("tbsCertificate")_
. Il calcule la signature
footnote:[On simplifie ici pour se concentrer sur les étapes importantes. En fait, le hash _M_ calculé n'est pas signé tel quel, il subit auparavant quelques transformations comme nous le verrons plus loin.]
footnote:[Ce calcul est le même que pour déchiffrer un message destiné au propriétaire de la clé publique (qui est ici l'émetteur du certificat). Signer en RSA revient à chiffrer en inversant le rôle de l'exposant public et privé.]
(notée _S_) avec la formule _S{nbsp}={nbsp}M^d^ mod n_

==== Vérification de la signature

. Le vérificateur calcule _M{nbsp}={nbsp}S^e^{nbsp}mod{nbsp}n_
. Il calcule _M'{nbsp}={nbsp}hash("tbsCertificate")_
. Si on a l'égalité _M{nbsp}={nbsp}M'_, la signature est vérifiée

=== Vérification du certificat de letsencrypto.org

==== Choix d'un programme de calcul

Nous avons besoin d'une "calculatrice" qui calcule sur des nombres entiers arbitrairement grands, sans perte de précision. Dans la suite de ce document, c'est _bc_ qui sera utilisé{nbsp}<<6>>.

* Linux{nbsp}: _bc_ est disponible par défaut sur la plupart des distributions.
* Windows{nbsp}: les binaires sont accessibles à l'URL{nbsp}<<7>>.

[NOTE]
.Le choix de bc
======================================
* _bc_ est installé par défaut sur la plupart des distributions Linux, et facile et rapide à installer sous Windows.
* _bc_ contient peu de fonctions mathématiques intégrées mais sur Internet on trouve de nombreux scripts qui permettent de l'enrichir considérablement.
** Dans _bc_ la variable _scale_ définit le nombre de décimales des nombres manipulés. Comme nous ne ferons que des calculs sur des entiers, nous laisserons _scale_ à zéro (pas de partie décimale). Zéro est la valeur par défaut de _scale_ au lancement de _bc_
footnote:[Lorsque _bc_ est lancé avec l'option *_-l_*, des fonctions mathématiques sont chargées au démarrage et _scale_ vaut 20. Nous ne nous servirons pas de cette option dans ce document et _scale_ sera toujours égal à zéro.]
.
======================================

[NOTE]
.Alternatives à bc
======================================
* *sagemath*, logiciel mathématique en licence GPL.
* *python*, langage de programmation en licence GPL, calcule par défaut sur des entiers de taille arbitrairement grande et convient donc aux calculs que nous allons faire.
* Logiciels mathématiques propriétaires bien connus.
======================================

.Comparaison entre _bc_ et _python_
[options="header"]
|=====================================
^|bc ^|python
2+^|Saisie d'un entier en hexadécimal
|Exécuter au préalable

`ibase = 2 * 8` footnoteref:[ibase16, _2 * 8_ produit toujours 16 (décimal). Si _16_ est lu alors qu'ibase vaut déjà 16, le résultat sera lu en hexadécimal et vaudra 22.]

Exemple{nbsp}:

`ibase = 2 * 8`

`var = ABEF0E0`

_(Attention les caractères hexadécimaux doivent être en majuscule.)_

|Saisir l'entier précédé de _0x_

Exemple{nbsp}:

`>>> var = 0xabef0e0`
footnote:[_python_ peut lire les nombres hexadécimaux indifféremment en majuscule et minuscule. _bc_ exige des majuscules.]

2+^|Affichage d'entier en hexadécimal
|Exécuter au préalable

`obase = 2 * 8`
footnoteref:[ibase16]

Exemple{nbsp}:

`obase = 2 * 8`

`2 ^ (2 ^ 4) + 1`
footnote:[Sous Windows, _bc_ a des difficultés à lire le caractère _circonflexe_ au clavier (en-dessous de la touche **9**). Pour contourner ce problème, il est possible d'utiliser (sur un clavier français) l'accent circonflexe à droite de la touche **P**, en appuyant dessus à deux reprises. Cela affiche deux _circonflexes_ et vous devez alors en supprimer un.]

`10001`

|Interpoler avec _%x_

Exemple{nbsp}:

`+++>>> '%x' % (2 ** (2 ** 4) + 1)+++`

`'10001'`
|=====================================

==== Enregistrement de la signature sous forme d'entier

. Depuis le navigateur, afficher la signature du certificat de _letsencrypt.org_.
. Sélectionner la signature et la copier-coller dans un éditeur de texte.
. Supprimer les caractère surnuméraires (enlever les ':' et les sauts de ligne).

. Passer les caractères hexadécimaux en majuscule footnote:[Si vous utilisez _python_, il est inutile de passer les caractères hexadécimaux en majuscule.].

. Ajouter _s=_ devant le nombre, et ajouter une première ligne _ibase = 2 * 8_.
. Enregistrer dans *_val.b_*.

Voir figures 9 et 10.

[caption="Fig. 9 : Signature dans le navigateur", title=" "]
image::img-cle-1-redim.png["Image signature dans navigateur"]

[caption="Fig. 10 : Fichier val.b", title=" "]
image::img-cle-2-redim.png["Image signature dans éditeur"]

L'instruction _ibase = 2 * 8_ ordonne à bc de lire les nombres en hexadécimal.
_ibase = 16_ fonctionne aussi, à condition qu'ibase soit égal à 10 (valeur par défaut) au moment d'exécuter _ibase = 16_.
Si ibase est déjà égal à 16 et que l'on exécute _ibase = 16_, une erreur se produit car bc lit 16 en hexadécimal (soit 22) et cette valeur est interdite.

[NOTE]
======================================
. Avec _bc_ il est impératif de passer les nombres hexadécimaux en majuscule.

. _bc_ n'accepte pas les noms de variable qui contiennent des majuscules.
======================================

Le navigateur affiche l'exposant de la clé RSA (le nombre noté _e_ tout à l'heure) sous forme décimale, alors que dans le script bc nous l'entrons en hexadécimal. Pour convertir un nombre décimal en hexadécimal, exécuter dans un terminal{nbsp}:

.Linux
[caption=""]
====
----
$ echo "obase=16; 65537" | bc
10001
----
====

.Windows
[caption=""]
====
----
$ echo obase=16; 65537 | bc.exe
10001
----
====

.Passer du texte en majuscule
****

.Linux
[caption=""]
====
Sous Linux, on peut utiliser la ligne de commande, par exemple (nombreuses autres solutions){nbsp}:
----
$ tr '[:lower:]' '[:upper:]' < fichier_entrée > fichier_sortie
----

Un éditeur suffisamment avancé comme _vim_ ou _emacs_ le permet aussi.
====

.Windows
[caption=""]
====
Windows ne dispose pas par défaut d'outil pour passer du texte en majuscule. Il faut installer _GNUWin32_ ou _cygwin_.

L'éditeur de texte (natif) adéquat pour ce type de transformation est *_notepad++_*, disponible à cette URL{nbsp}<<8>>.

[NOTE]
_vim_ et _emacs_ sont disponibles sous Windows.
====
****

==== Enregistrement de la clé publique sous forme d'entier

Depuis le navigateur{nbsp}:

. Sélectionner le certificat de _TrustID Server CA A52_ et afficher sa clé publique.
. Sélectionner la valeur de la clé publique et la copier-coller dans *_val.b_*.
Il faut le faire en deux fois, une fois pour le modulo de 256 octets (variable _n_) et une fois pour l'exposant (variable _e_).

Ne pas oublier de passer les caractères hexadécimaux en majuscule.

[caption="Fig. 11 : Clé publique dans le navigateur", title=" "]
image::img-cle-3-redim.png["Image clé dans navigateur"]

A l'arrivée, *_val.b_* contient trois variables, s, n et e.

.val.b
[source, bc]
----
ibase=2*8

s=8049A7CE9627701FC4E520876B97271A8AEF34D13A5ECA776172BD7C9053DBEF9C8504E4C85629135D934D1F9C6FB09375189812B3475D5F0797F5D32BC9B11B12BC29733DCD40E57EB97BC819F21939764A4F2A270036906BAE5FD280D68DCC16428C0FCD3D213025BCFA10A6697529ED1A168E0D2CEFCB24A9C9A64C85F0BF8942B91F2CD1E92989F73EF9F2267BAB5535C3388C10C3C1D55DBC3A50A01A77CEDED612862D83A9B1A68A08B68DC35BE0F2E23E3BD9AFD4C0BA1537CFD694A5AF5D6CF8887861A9DCB89B9DE35AD3F255C251B0ECD54C2CF693DD5732EDF33939334BDB1E64C29636E0502E57914984BDA74C7E05AC948403D2BEBE051452F8

n=9769D7999885023FE9264276E8F4733FA932442690782E78579119A05D762B49F9935A5D5ACE82F3C2D8E54C367A2B1D0DDBA6A7FE91127CED7201B78CA1C5DACC9DFE09FB57E214470FE89E918F942D8032939303F5287868BA7E0F42B4317A0514225333E4A3AD6C8FAFBE636BB2329FD917B9C9E0607C99D631E1E4A0B73FAFB232AC7E8C9CDC02EBE1BC1F149CBC91F7B2FB42F3E1202BCBBF8FF3B37063FAF7752802ABC5D4B0EDEA257F87CD371496833C40021BA09E19477FF3B0CCC52560B83512F151EB17DCFC5BA5D99BEF404CD77771E9FB458B7EF2E369B042661746903ACD463DF1B0096FDCFFEE3361CAFCC72E3CED5E0AD1BF221269804B23

e=10001

----

==== La fonction powmod

Les amateurs de _python_ ont encore un avantage à ce stade. L'équivalent de la fonction _powmod_ y est disponible sous forme d'un troisième paramètre (facultatif) à la fonction _pow_.

Pour ceux qui utilisent bc comme moi, il faut écrire la fonction.

La fonction _powmod_ met en oeuvre l'algorithme d'exponentiation rapide, décrit à cette URL{nbsp}<<9>>.
En fait nous sommes dans un contexte modulaire et d'après Wikipédia le nom exact de l'algorithme est _exponentiation modulaire_. Un article y est consacrée{nbsp}<<10>>.
Les deux algorithmes font appel au même principe, mais le second exploite le contexte modulaire pour que les nombres manipulés n'atteignent pas une taille démesurée. C'est le second algorithme (_exponentiation modulaire_) dont nous avons besoin pour la suite.

Sur Internet, on peut trouver la fonction _powmod_ dans de nombreux scripts _bc_ à télécharger. À noter qu'elle porte parfois d'autres noms, _mpower_ par exemple.

.powmod.b
[source, bc]
----
include::powmod.b[]
----

==== Calcul de _M_

Nous voilà prêts pour calculer _M_.

. Lancer la commande suivante footnote:[Par défaut, _bc_ ajoute un anti-slash après le 68e caractère et passe à la ligne suivante. On peut modifier ce comportement avec la variable d'environnement _BC_LINE_LENGTH_. Quand cette variable est égale à zéro, les nombres ne sont pas coupés.]{nbsp}:
----
$ BC_LINE_LENGTH=0 bc powmod.b val.b
----
[start=2]
. Dans le shell _bc_, exécuter
footnoteref:[ibase16] (pour que les nombres soient affichés en hexadécimal)
----
obase=2*8
----
[start=3]
. Toujours dans le shell _bc_, exécuter
----
powmod(s, e, n)
----

Rappelons que c'est _S_ (variable _s_ dans _val.b_) qui doit être élevé à la puissance _e_, modulo _n_.
Lors de la définition d'obase, ibase vaut 16 (résultat du script _val.b_ chargé au démarrage) donc obase=16 ne fonctionnerait pas.

[caption="Fig. 12 : Calcul pour vérifier la signature RSA", title=" "]
image::img-powmod-redim.png["Image résultat powmod"]

[IMPORTANT]
Au démarrage de bc, ibase est égal à 16 du fait du chargement de _val.b_. Si vous exécutez obase = 16, obase sera égal à... 22 !
C'est logique, puisque 16 est saisi en hexadécimal. Le plus simple est d'utiliser _2{nbsp}*{nbsp}8_ comme indiqué. Vous pouvez aussi exécuter _obase = 10_ (ibase étant égal à 16), mais c'est moins clair, et vous devez être certain qu'ibase vaut bien 16 au moment d'exécuter _obase = 10_, pour passer l'affichage des nombres en hexadécimal
(_2{nbsp}*{nbsp}8_ fonctionne toujours quelle que soit la valeur d'ibase, y compris pour les valeurs inférieures ou égales à 7).

Le résultat (figure 12) avec tous ces _F_ prouve avec une quasi certitude que le calcul s'est bien passé.
Les _F_ correspondent au 'padding' standard effectué pour une signature RSA, la valeur qui suit (à partir de *`303130`*) est le hash de tbsCertificate "emballé".

"Emballé", c'est-à-dire ? La valeur est spécifiée en ASN.1 et codée en DER, et elle contient d'autres informations que le seul hash de tbsCertificate.

C'est ce que nous allons voir dans le chapitre suivant.

==== Analyse de _M_

Nous allons procéder en trois étapes{nbsp}:

. Enregistrement du contenu hexadécimal
. Conversion du contenu hexadécimal en binaire
. Examen du contenu binaire avec la commande _openssl asn1parse_

===== 1 Enregistrement du contenu hexadécimal

Faisons un copier-coller de _M_ (en hexadécimal) à partir de l'octet qui suit l'octet nul, et enregistrons le résultat dans le fichier *_m.hex_*.

[caption="Fig. 13 : m.hex", title=" "]
image::img-m.hex-redim.png["Image m.hex"]

.Contenu de m.hex
----
include::m.hex[]
----

===== 2 Conversion du contenu hexadécimal en binaire

Maintenant nous allons convertir _m.hex_ en binaire, puisque le contenu actuel est le _codage des octets en hexadécimal_ de la signature, ce n'est pas la signature elle-même.

.Linux
[caption=""]
====
Exécuter la commande
----
$ xxd -r -p m.hex > m.der
----
====

.Windows
[caption=""]
====
Le plus simple est d'utiliser _notepad++_ et d'enregistrer le fichier transformé avec le nom _m.der_.

[caption="Fig. 14 : Avant la conversion hexadécimal -> binaire", title=" "]
image::img-notepadpp-1-redim.png["Image notepad++ 1"]

[caption="Fig. 15 : Après la conversion hexadécimal -> binaire", title=" "]
image::img-notepadpp-2-redim.png["Image notepad++ 2"]

[CAUTION]
[caption="Attention"]
======================================
Ne pas laisser un saut de ligne à la fin du fichier qui s'ajouterait aux données binaires de la signature.
======================================
====

Le fichier _m.der_ contient les octets que l'on avait dans la signature, ce que l'on peut vérifier facilement...

* ... sous Linux avec la commande _hd_ (on peut aussi utiliser _hexdump_ ou _xxd_).
* ... sous Windows avec _notepad++_, en reconvertissant en hexadécimal et en vérifiant que l'on retombe sur ses pieds.

[caption="Fig. 16 : Contenu du fichier binaire m.der", title=" "]
image::img-m.der-redim.png["Image m.der"]

===== 3 Examen du contenu DER du fichier m.der

.openssl
****
Pour afficher le contenu binaire (qui se trouve être encodé en DER) nous allons utiliser l'exécutable en ligne de commande fourni avec la librairie openssl. Cet outil s'appelle _openssl_.

Par la suite nous utiliserons également _dder_ et _pkfile_, deux utilitaires créés par l'auteur de cet article pour afficher et extraire plus facilement ce type de données.

_dder_ est disponible à l'URL{nbsp}<<11>>.

_pkfile_ est disponible à l'URL{nbsp}<<12>>.

.Exécutable openssl

* Sous Linux ce programme est disponible par défaut.
* Sous Windows il faut trouver un binaire à télécharger.
Le plus simple est de télécharger la version GNUWin32, disponible à cette URL{nbsp}<<13>>.
+
La version proposée au téléchargement (en février 2016) date de 2008. Des binaires plus récents sont disponibles sur Internet.
Pour faire les manipulations décrites dans ce document, la version de GNUWin32 est suffisante.
+
** À noter que Sous Windows les environnements "de taille importante" (_cygwin_, _perl_, ...) sont souvent installés avec leur librairie openssl, qui contient l'outil en ligne de commande _openssl_.
****

Exécuter la commande
----
$ openssl asn1parse -inform der -in m.der
----

[caption="Fig. 17", title=" "]
image::img-m.der-openssl-redim.png["Image m.der avec openssl"]

Nous verrons dans le chapitre suivant la syntaxe ASN.1 plus en détail.

La commande _openssl_ (figure 17) nous donne deux informations{nbsp}:

* L'algorithme de hash est SHA-256, ce que l'on savait déjà d'après le contenu de _signatureAlgorithm_ (deuxième partie de la structure en trois parties du certificat).
* Nous voyons la valeur du hash (le bloc *`prim: OCTET STRING`*) sous forme hexadécimale. Sa longueur correspond bien au SHA-256 (256 bits de longueur soit 32 octets).

Nous savons désormais que la signature SHA-256 de la valeur tbsCertificate du certificat de _letsencrypt.org_ devrait être{nbsp}:
----
8364DA78F1FD8DCC6812E568268BF2DAF8791BE383109745388879C496A8C3DD
----

C'est ce que nous allons vérifier en calculant maintenant _M'_.

==== Calcul de _M'_

Nous allons calculer _M'_ en deux étapes{nbsp}:

. Extraction de tbsCertificate du certificat _letsencrypt.org_.
. Calcul du hash SHA-256 de tbsCertificate.

Mais avant d'extraire tbsCertificate, nous devons comprendre comment le certificat est structuré et codé.

===== ASN.1 et DER

Au début de ce document, nous avons observé que la section 4.1 de la RFC 5280, qui définit la structure des certificats x509 v3, contient cette définition{nbsp}:

--------------------------------------
Certificate  ::=  SEQUENCE  {
	tbsCertificate       TBSCertificate,
	signatureAlgorithm   AlgorithmIdentifier,
	signatureValue       BIT STRING  }
--------------------------------------

Un certificat x509 est défini selon la syntaxe ASN.1.
L'encodage peut être BER
footnote:[BER signifie **B**asic **E**ncoding **R**ules]
, CER
footnote:[CER signifie **C**anonical **E**ncoding **R**ules]
ou DER
footnote:[DER signifie **D**istinguished **E**ncoding **R**ules]
.

Ces trois standards sont très proches, l'intérêt de DER étant son unicité{nbsp}: une structure de données spécifiée en ASN.1 ne peut être encodée en DER que d'une manière, et une seule. BER et CER permettent certaines variations dans la manière d'encoder.

Pour ne pas alourdir la rédaction, nous parlerons toujours d'encodage DER ou simplement DER, même lorsque les données manipulées pourraient ne pas être DER
footnote:[La RFC 5280 indique que les _données signées_ d'un certificat (la partie tbsCertificate) doivent être encodées en DER, mais ne donne pas d'indication pour le reste.]
.

ASN.1 structure chaque valeur (_data value_ dans le document X.690) selon la typologie **T**{nbsp}-{nbsp}**L**{nbsp}-{nbsp}**V** ou **T**ag{nbsp}-{nbsp}**L**ength{nbsp}-{nbsp}**V**alue.
La forme "longueur indéfinie" apporte un quatrième élément, "end-of-contents" (marqueur de fin de valeur), que nous ignorerons car DER ne permet pas cette forme.

[**T**]ag::
Définit toutes les caractéristiques de la valeur, notamment son _type_, par exemple une date (_UTCTime_), une séquence (_SEQUENCE_ ou _SEQUENCE OF_), un entier (_INTEGER_), et bien d'autres. Il définit également si l'encodage de la valeur est _primitive_ ou _contructed_.
Encodage _primitive_:::
La donnée ne contient pas de sous-structure
Encodage _constructed_:::
La donnée est elle-même une structure qui suit la typologie **T**-**L**-**V**, et ici, cette structure est elle-même définie en ASN.1{nbsp}footnote:[Certains types de données, notamment les _*string_ (OCTET STRING, UTF8String, etc.), peuvent être _primitive_ ou _constructed_, ce qui signifie que leur encodage peut suivre une structure hiérarchique "propre à l'encodage", non explicitée dans la définition de la valeur en ASN.1.].
Structure hiérarchique:::
La différence _primitive_ - _constructed_ est à la base de la structure hiérarchique d'une spécification ASN.1, les éléments _constructed_ étant les branches, les éléments _primitive_ étant les feuilles.
+
Dans la définition d'un _Certificate_ ci-dessus, le type _SEQUENCE_ est, par définition du type _SEQUENCE_ en ASN.1, _constructed_. Cela signifie que la valeur _SEQUENCE_ est elle-même une structure ASN.1, ce qu'on peut voir dans la liste des trois composants d'un certificat définie entre accolades.

[**L**]ength::
Donne la longueur de la valeur en octets.

[**V**]alue::
Est la donnée elle-même. Dans ce document nous employons le terme _valeur_ (dans le document X.690 le terme est _data value_).


Affichons le contenu DER avec l'utilitaire en ligne de commande _dder_ en exécutant la commande suivante{nbsp}:
----
$ dder -width 8 -recursive "|  " m.der
----

[caption="Fig. 18", title=" "]
image::img-dder-redim.png["Image lecture m.der avec dder"]

La copie d'écran de la figure 18 a été faite sous Windows pour changer un peu.

La description de la valeur indique _-cons_ ou _-prim_, pour _constructed_ ou _primitive_.
Chaque fois que le tag indique une valeur _constructed_ (ici, il s'agit à deux reprises du type _SEQUENCE_, qui est obligatoirement _constructed_), on descend d'un niveau dans la structure hiérarchique, que l'on a fait ressortir ici avec l'option _-recursive "|  "_.

===== Extraction de tbsCertificate du certificat _letsencrypt.org_

===== Étape 1 de l'extraction
Commençons par enregistrer le certificat depuis le navigateur, dans le fichier _letsencryptorg.der_.

.Firefox
[caption=""]
====
Afficher le certificat comme vu précédemment, puis afficher l'onglet _Détails_ et cliquer sur le bouton _Exporter_.
Ensuite sélectionner _Certificat X.509 (DER)_.

[caption="Fig. 19", title=" "]
image::img-certsave-ff-redim.png["Enregistrement certificat depuis Firefox"]
====

.Internet Explorer et Chrome
[caption=""]
====
Afficher le certificat, puis cliquer sur le bouton _Copier dans un fichier..._.
Ensuite sélectionner _X.509 binaire encodé DER_.

[caption="Fig. 20", title=" "]
image::img-certsave-ie-redim.png["Enregistrement certificat depuis IE et Chrome"]
====

[NOTE]
.PEM versus DER
======================================
Avec les certificats x509, l'encodage PEM est une surcouche de DER qui consiste à{nbsp}:

* Encoder le contenu binaire (après chiffrement éventuel) en BASE64
* Ajouter au début et à la fin un texte standardisé qui définit et délimite la nature du contenu, ainsi que les informations de chiffrement s'il y a lieu
** La ligne ajoutée au début commence par *`-----BEGIN`*
** La ligne ajoutée à la fin commence par *`-----END`*

Si vous avez enregistré le certificat avec un encodage PEM, vous pouvez le convertir en DER avec _openssl_. Exemple pour _letsencrypt.cer_ (PEM) que l'on convertit en _letsencrypt.der_ (DER){nbsp} - comme on peut voir, l'encodage par défaut avec _openssl_ est PEM.
----
$ openssl x509 -in letsencryptorg.cer -outform der -out letsencryptorg.der
----

[caption="Fig. 21", title=" "]
image::img-pem-redim.png["Exemple encodage PEM"]

[caption="Fig. 22", title=" "]
image::img-convpemder-redim.png["Exemple conversion PEM vers DER"]

Vous pouvez faire cette conversion "à la main" en enlevant la première et la dernière ligne et en faisant une conversion BASE64{nbsp}->{nbsp}binaire avec des outils comme _base64_ (Linux) ou _notepad++_ (Windows).
======================================

===== Étape 2 de l'extraction
Nous disposons maintenant d'un certificat enregistré en binaire (encodage DER) dans le fichier _letsencryptorg.der_, dont nous allons à présent extraire la partie tbsCertificate.

[NOTE]
======================================
Les outils _dder_ et _pkfile_ (_pkfile_ est présenté plus loin) peuvent lire indifféremment des fichiers codés en PEM ou en DER. Si le fichier est PEM, il est décodé à la volée.
======================================

Il y a deux solutions pour ce faire

. À la main
. À l'aide de l'utilitaire _pkfile_. _pkfile_ est disponible à cette URL{nbsp}<<12>>.

.Extraction de tbsCertificate{nbsp}: alernative 1 (à la main)

Un éditeur de fichier binaire ferait l'affaire, mais la manipulation est plus claire si l'on affiche le contenu hexadécimal avec _dder_.

Exécuter la commande
----
$ dder -recursive "|  " -hex letsencryptorg.der > d
----

[NOTE]
.Encodage des fichiers affichés par dder
======================================
_dder_ lit indifféremment des fichiers PEM et DER. Si le fichier est PEM il décode (et décrypte si nécessaire) les données en mémoire avant d'afficher le contenu DER.

Donc la commande aurait pu être (avec le fichier _letsencryptorg.cer_ encodé en PEM){nbsp}:
----
$ dder -recursive "|  " -hex letsencryptorg.cer > d
----
======================================

Ouvrir le fichier _d_ dans un éditeur de texte.
Comme on a affiché le contenu avec un décalage à chaque niveau hiérarchique (option _-recursive "|  "_), la structure en trois parties des certificats x509 ressort bien.

Supprimer les deux premières lignes et un certain nombre de lignes à la fin pour que seul demeure le contenu de tbsCertificate. Ci-dessous, le texte à conserver est le texte sélectionné (les lignes au milieu ont été supprimées pour condenser l'image).

[caption="Fig. 23", title=" "]
image::img-extracttbs-alt1-1.png["Image extraction tbsCertificate alternative 1 - 1"]

[caption="Fig. 24", title=" "]
image::img-extracttbs-alt1-2-redim.png["Image extraction tbsCertificate alternative 1 - 2"]

Ensuite{nbsp}:

* Supprimer les "|" en début de ligne
* Supprimer l'offset (numéro sur six caractères)
* Supprimer le texte après les codes hexadécimaux (une fois supprimé les "|" et l'offset en début de ligne, ce sont tous les caractères au-delà de la 55e position qu'il faut supprimer).
* Supprimer tous les espaces

[caption="Fig. 25", title=" "]
image::img-extracttbs-alt1-3-redim.png["Image extraction tbsCertificate alternative 1 - 3"]

On retrouve (figure 25) une sous-partie du fichier _letsencryptorg.der_, codée en hexadécimal, qui commence par *`308205ea`* et se termine par *`2e6f7267`*.

[NOTE]
======================================
Cette manipulation peut être faite avec un programme d'édition de fichier binaire, en ne gardant que les données à partir de l'offset 4, d'une longueur de 1518 octets.
======================================

Il faut ensuite convertir le contenu "codé hexadécimal" en binaire comme cela a été vu précédemment (commande _xxd -r -p_ sous Linux, avec _notepad++_ sous Windows).

Au final on obtient le fichier _tbs.der_ comme montré sur la figure 26.

[caption="Fig. 26", title=" "]
image::img-extracttbs-alt1-4-redim.png["Image extraction tbsCertificate alternative 1 - 4"]

.Extraction de tbsCertificate{nbsp}: alernative 2 (à l'aide de _pkfile_)

Exécuter la commande
----
$ pkfile letsencryptorg.der -l 2
----

[caption="Fig. 27", title=" "]
image::img-extracttbs-alt2-1-redim.png["Image extraction tbsCertificate alternative 2 - 1"]

Le résultat visible sur la figure 27 nous montre que le tbsCertificate correspond à la valeur _SEQUENCE_ de 1518 octets (4 octets d'en-tête, 1514 octets de données). _pkfile_ donne à cette valeur les coordonnées 1.1.

Nous enregistrons cette valeur en binaire dans le fichier _tbs2.der_ en exécutant la commande
----
$ pkfile letsencryptorg.der -n 1.1 -x -o tbs2.der
----

[caption="Fig. 28", title=" "]
image::img-extracttbs-alt2-2.png["Image extraction tbsCertificate alternative 2 - 2"]

[NOTE]
.Encodage des fichiers analysés par pkfile
======================================
_pkfile_ lit indifféremment des fichiers PEM et DER. Si le fichier est PEM il décode (et décrypte si nécessaire) les données en mémoire avant de traiter le contenu DER.
======================================

===== Calcul du hash de tbsCertificate

.Linux
[caption=""]
====
Le calcul des différents algorithmes de hash est disponible en ligne de commande. Pour SHA-256 le programme est _sha256sum_.

Exécuter
----
$ sha256sum tbs.der
----

[caption="Fig. 29", title=" "]
image::img-calchash-1-redim.png["Calcul hash Linux"]
====

.Windows
[caption=""]
====
Lels outils de calcul de hash ne sont pas disponibles par défaut. Voici quelques solutions (d'autres existent){nbsp}:

* Utiliser _pkfile_, qui permet de calculer différents hashfootnote:[_pkfile_ peut le faire aussi sous Linux, mais dans ce système il est plus logique d'utiliser les programmes déjà installés. La fonctionnalité de calcul de hash a été ajoutée à _pkfile_ pour simplifier les manipulations sous Windows.]
.
* Installer les outils _GNUWin32_, disponibles à cette URL{nbsp}<<13>>.
* 7-ZIP ajoute des menus contextuels dans l'explorateur pour calculer différents hashs, dont SHA-256. 7-ZIP est disponible à cette URL{nbsp}<<14>>.

Exemple avec _pkfile_, exécuter
----
$ pkfile --sha256 tbs.der
----

[caption="Fig. 30", title=" "]
image::img-calchash-2.png["Calcul hash Windows, 2"]

[caption="Fig. 31", title=" "]
image::img-calchash-3.png["Calcul hash Windows, 3"]
====

Les captures d'écran montrent également le calcul sur le fichier _tbs2.der_ (créé avec _pkfile_), qui est ben identique à _tbs.der_, ce qui confirme au passage l'équivalence des deux termes de l'alternative pour extraire tbsCertificate.

**Le hash trouvé (_M'_) concorde avec la signature (_M_), ce qui valide la signature du certificat _letsencrypt.org_**

=== Conclusion

Nous arrivons au terme des manipulations à effectuer pour vérifier la signature RSA d'un certificat x509. Les calculs étaient élémentaires, mais cela nous a permis de voir{nbsp}:

* Les différents formats et encodages et les outils pour passer de l'un à l'autre
** PEM versus DER
** BASE64 versus binaire
** Hexadécimal versus binaire
** ASN.1
** La structure de certificat x509
* Les solutions pour calculer sur des entiers de grande taille
** _python_ (évoqué ici mais non détaillé) et _bc_
** Les transformations éventuelles et précautions à prendre pour calculer en saisie et affichage hexadécimal
** La création de la fonction _powmod_ dans _bc_
* Outils divers
** Calcul du hash d'un fichier
** Extraction d'une valeur d'un fichier encodé en DER

La _signature_ a été vérifiée mais le certificat lui-même n'a pas été validé en totalité. Il y a deux raisons à cela.

. Une fois un certificat vérifié, il faut vérifier son parent dans la hiérarchie (le certificat qui l'a signé), et ainsi de suite, jusqu'à vérifier un certificat connu dans la base des certificats du navigateur (les certificats _racine_).
. Le navigateur vérifie si les certificats rencontrés ont été révoqués à l'aide des Listes de Révocation des Certificats ou _CRL_ (_**C**ertificate **R**evocation **L**ist_).

<<<

== Vérification de signature ECDSA

=== Cryptographie à courbes elliptiques

Ce document se concentre sur les problématiques de calcul effectif et de formats de fichiers.
Nous n'allons pas expliquer ici toute la cryptographie à base de courbes elliptiques, nous allons simplement en résumer les grandes lignes, donner les formules applicables et quelques définitions.

==== Les deux familles de courbes elliptiques

Les courbes sur _F~2^m^~_ (_binary field_)::
Cette notation est un raccourci. On a _F~2^n^~ = F~2~[x]/(p(x))_ où _p(x)_ est un polynôme irréductible de degré _n_ (source{nbsp}: <<15>>). Les "nombres" manipulés sont des polynômes sur _F~2~_ et les opérations sont faites modulo _p(x)_. L'équation de la courbe (source{nbsp}: <<16>>) est
+
_y^2^ + xy = x^3^ + ax^2^ + b_
+
Les opérations sur _F~2^m^~_ portent sur des polynômes et leur arithmétique est distincte de l'arithmétique usuelle sur les nombres entiers. Par exemple quel que soit _A_ de _F~2^m^~_, on a _A{nbsp}+{nbsp}A{nbsp}={nbsp}0_ (soit _A{nbsp}={nbsp}-A_ pour tout _A_).

Les courbes sur _F~p~_ (_prime field_)::
_p_ est un nombre premier. On a _F~p~ = Z/pZ_ (source{nbsp}: <<17>>). Les opérations sont faites modulo _p_. L'équation de la courbe est (source{nbsp}: <<16>>)
+
_y^2^ = x^3^ + ax + b_

==== Les paramètres de domaine

Ces paramètres définissent les caractéristiques de la courbe. Une clé est définie pour une courbe et une seule, la courbe étant entièrement déterminée par ses paramètres de domaine. On parle aussi de paramètres de la courbe.

Source{nbsp}: <<16>>.

* Sur _F~2^m^~_, les paramètres sont (_m_, _f(x)_, _a_, _b_, _G_, _n_, _h_)
** _m_, entier qui définit _F~2^m^~_.
** _f(x)_, polynôme irréductible de degré _m_.
** _a_ et _b_, les paramètres de l'équation _y^2^ + xy = x^3^ + ax^2^ + b_.
** _G_, le générateur du groupe noté _E(F~2^m^~)_ (_G_ est donc un point de la courbe).
** _n_ est l'ordre du groupe généré par _G_.
** _h_ est le cofacteur, c'est le nombre d'éléments de _E(F~2^m^~)_ divisé par _n_.

* Sur _F~p~_, les paramètres sont (_p_, _a_, _b_, _G_, _n_, _h_)
** _p_, nombre premier.
** _a_ et _b_, les paramètres de l'équation _y^2^ (mod p) = x^3^ + ax + b (mod p)_.
** _G_, le générateur du groupe noté _E(F~p~)_ (_G_ est donc un point de la courbe).
** _n_ est l'ordre du groupe généré par _G_.
** _h_ est le cofacteur, c'est le nombre d'éléments de _E(F~p~)_ divisé par _n_.

.Les courbes nommées

Toute information pratique sur les courbes elliptiques (clé privée ou publique, signature...) n'est exploitable qu'avec les paramètres de domaine de la courbe elliptique utilisée.
Les paramètres de domaine peuvent être donnés de deux manières{nbsp}: tels quels (les différents éléments vus précédemment et qui définissent une courbe, tels que _a_, _b_, _G_, etc.), ou bien sous la forme d'une _courbe nommée_.

_openssl_ peut lister les courbes nommées{nbsp}:

 $ openssl ecparam -list_curves
   secp112r1 : SECG/WTLS curve over a 112 bit prime field
   secp112r2 : SECG curve over a 112 bit prime field
   [...]
   brainpoolP512r1: RFC 5639 curve over a 512 bit prime field
   brainpoolP512t1: RFC 5639 curve over a 512 bit prime field

La commande suivante permet d'afficher les détails d'une courbe, exemple avec _secp256r1_{nbsp}:

 $ openssl ecparam -name secp256r1 -noout -text
 using curve name prime256v1 instead of secp256r1
 ASN1 OID: prime256v1
 NIST CURVE: P-256

_openssl_ nous avertit que _secp256r1_ (définition "SECG"{nbsp}: <<18>>) est en fait la courbe _NIST P-256_ (définie ici <<19>>), qui porte le nom _prime256v1_ dans le standard _X9.62_.

Tout ça pour dire quoi{nbsp}? Rien, à part que l'on peut se féliciter de vivre à l'heure d'Internet pour s'y retrouver dans la jungle des documents de normalisation.

Et les paramètres de domaine{nbsp}? Il faut demander à _openssl_ d'afficher les paramètres de la courbe sous forme explicite{nbsp}:

 $ openssl ecparam -name secp256r1 -noout -text -param_enc explicit
 using curve name prime256v1 instead of secp256r1
 Field Type: prime-field
 Prime:
     00:ff:ff:ff:ff:00:00:00:01:00:00:00:00:00:00:
     00:00:00:00:00:00:ff:ff:ff:ff:ff:ff:ff:ff:ff:
     ff:ff:ff
 A:
     00:ff:ff:ff:ff:00:00:00:01:00:00:00:00:00:00:
     00:00:00:00:00:00:ff:ff:ff:ff:ff:ff:ff:ff:ff:
     ff:ff:fc
 B:
     5a:c6:35:d8:aa:3a:93:e7:b3:eb:bd:55:76:98:86:
     bc:65:1d:06:b0:cc:53:b0:f6:3b:ce:3c:3e:27:d2:
     60:4b
 Generator (uncompressed):
     04:6b:17:d1:f2:e1:2c:42:47:f8:bc:e6:e5:63:a4:
     40:f2:77:03:7d:81:2d:eb:33:a0:f4:a1:39:45:d8:
     98:c2:96:4f:e3:42:e2:fe:1a:7f:9b:8e:e7:eb:4a:
     7c:0f:9e:16:2b:ce:33:57:6b:31:5e:ce:cb:b6:40:
     68:37:bf:51:f5
 Order:
     00:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:ff:ff:
     ff:ff:bc:e6:fa:ad:a7:17:9e:84:f3:b9:ca:c2:fc:
     63:25:51
 Cofactor:  1 (0x1)
 Seed:
     c4:9d:36:08:86:e7:04:93:6a:66:78:e1:13:9d:26:
     b7:81:9f:7e:90

Tous ces paramètres ont été vus plus haut, sauf _Seed_. Qu'en est-il{nbsp}?

_Seed_ est un nombre arbitraire à partir duquel les autres paramètres de la courbe ont été déterminés, de manière vérifiable par n'importe qui, selon une spécification _X9.62_. Cela garantit qu'ils n'ont pas été choisis en raison de propriétés cachées qui permettraient à leur inventeur de casser la protection facilement. _Seed_ est à l'origine des paramètres de la courbe mais il n'en fait pas partie. Le passage de _Seed_ aux paramètres utilise une fonction de hachage à sens unique, ce qui garantit que le choix ne s'est pas fait dans l'autre sens (détermination de paramètres ad hoc puis du _Seed_ correspondant).

.Le x509

La RFC 5480 (<<20>>) interdit expressément l'usage de paramètres explicites dans le standard x509, seules les courbes nommées peuvent y être utilisées.

Nous allons maintenant nous intéresser aux courbes sur les corps premiers (_F~p~_).
Les courbes binaires fonctionnent selon les mêmes principes mais les "nombres" manipulés sont des polynômes sur _F~2~_, et si l'on souhaite y mener des calculs avec _bc_ ou _python_, cela nécessite de coder spécifiquement leur arithmétique. Dans ce document nous ferons des calculs sur _F~p~_ uniquement.

==== L'arithmétique des courbes sur _F~p~_

Les calculs sont faits modulo _p_ et nous ne le préciserons plus par la suite{nbsp}footnote:[Dans la signature ECDSA certains calculs sont faits modulo _n_, l'ordre du groupe associé à la courbe. Cela sera signalé. À défaut, tous les calculs sont faits modulo _p_.].

.Clés privée et publique

La construction d'une paire de clés privée et publique consiste à

. Choisir un entier _k_ inférieur à _p_
. Calculer _Q = kG_ où _G_ est l'un des paramètres de domaine de la courbe (voir ci-après la multiplication d'un point par un scalaire)

Le point _Q_ est la clé publique, l'entier _k_ est la clé privée. Ainsi contrairement au RSA où la clé privée et publique ont même nature (ce sont deux entiers), ici la clé publique est un point tandis que la clé privée est un entier.

.Addition de deux points distincts (et non alignés verticalement)

La signification de l'addition de deux points est géométrique et on peut le voir ici{nbsp}<<21>>.

Les formules qui en découlent sont les suivantes, pour _R{nbsp}={nbsp}P{nbsp}+{nbsp}Q_ de coordonnées (_r~x~_, _r~y~_), (_p~x~_, _p~y~_) et (_q~x~_, _q~y~_) respectivement, _P_ étant différent de Q et non aligné verticalement avec _Q_{nbsp}:

image::img-point-add.png["Addition de deux points"]

.Addition d'un point avec lui-même

Pour _P{nbsp}={nbsp}Q_, le calcul de _R{nbsp}={nbsp}P{nbsp}+{nbsp}P{nbsp}={nbsp}2P_ est (en reprenant les notations précédentes){nbsp}:

image::img-point-dbl.png["Addition d'un point avec lui-même"]

[IMPORTANT]
Le symbole de fraction n'est pas la division euclidienne mais la multiplication par l'inverse modulo _p_.

.Multiplication d'un point par un entier naturel

Avec les formules qui précèdent, on sait calculer _P{nbsp}{plus}{nbsp}P{nbsp}={nbsp}2P_, _P{nbsp}{plus}{nbsp}2P{nbsp}={nbsp}3P_, et ainsi de suite.
On sait donc calculer _kP_, _k_ entier.

[NOTE]
.Addition de deux points alignés verticalement
======================================
Si _P_ et _Q_ sont alignés verticalement ils sont opposés (cela découle du terme _y^2^_ de l'équation), on a donc _P{nbsp}={nbsp}-Q_ que l'on peut aussi écrire _P{nbsp}{plus}{nbsp}Q{nbsp}={nbsp}O_. _O_ est le "point à l'infini" de la courbe elliptique et il joue le même rôle que zéro dans l'addition des entiers. Ainsi on a _P{nbsp}{plus}{nbsp}O{nbsp}={nbsp}O{nbsp}{plus}{nbsp}P{nbsp}={nbsp}O_ quel que soit _P_ sur la courbe.
======================================

.Multiplication par un entier _k_ très grand

Les _k_ utilisés en pratique étant des grands nombres (de l'ordre de 2^256^ avec _prime256v1_), il n'est pas possible de calculer _kP_ en ajoutant _P_ à lui-même _k_ fois.

Il faut utiliser l'algorithme d'exponentiation rapide vu précédemment{nbsp}: <<9>>.
Remplacer la multiplication de deux entiers par l'addition de deux points et l'élévation à la puissance par la multiplication d'un point par un entier.

==== Fonctions de calcul sur _F~p~_ avec le programme _bc_

Nous allons maintenant écrire les fonctions de calcul d'après les formules qui précèdent.

Un point est représenté par un tableau et la convention du script est la suivante{nbsp}:

* Le point à l'infini est codé par _point[2]_ différent de zéro
* Sinon (si _point[2]_ est nul), _point[0]_ est la coordonnée _x_ et _point[1]_ est la coordonnée _y_.

Le calcul de l'inverse modulaire utilise l'_algorithme d'Euclide étendu_ <<22>>.

[NOTE]
Ce script contient la fonction _powmod_ utilisée précédemment, pour le RSA. Nous n'en avons pas besoin pour les calculs ECDSA.

[IMPORTANT]
.L'opérateur modulo
======================================
L'opérateur _%_ (_modulo_) ne fonctionne pas à l'identique d'un langage à l'autre ou d'une librairie à l'autre.

* _bc_ renvoie un nombre dont le signe est le signe du premier argument.
Ainsi _(-5){nbsp}%{nbsp}3_ renvoie _-2_.
* _python_ renvoie toujours une valeur positive. _(-5){nbsp}%{nbsp}3_ renvoie _1_.
* La librairie _libgmp_ (_GNU Multiple Precision Arithmetic Library_) renvoie toujours une valeur positive. _(-5){nbsp}%{nbsp}3_ renvoie _1_.

Cela ne change pas la nature des calculs effectués mais doit parfois être pris en compte. Ainsi la fonction _invmod_ (définie dans _crypto.b_ ci-dessous) ne peut pas fonctionner avec des nombres négatifs et elle commence par "normaliser" le premier argument pour qu'il soit compris entre _0_ et _n{nbsp}-{nbsp}1_.
======================================

.crypto.b
[source, bc]
----
include::crypto.b[]
----

[NOTE]
.Optimisation et robustesse
======================================
Sur Internet on trouve des scripts qui appliquent la première formule (addition de deux points distincts) et la deuxième (doubler un point) sans vérifier les cas "P et Q alignés verticalement" ou "Point à l'infini".

Dans la pratique ce n'est pas un souci car les nombres manipulés avec des clés x509 ne conduisent jamais à ces cas limites.
La fonction _ec_mul_ pourrait ainsi être plus efficace, en appelant directement les fonctions ec_add_core et ec_dbl_core.
======================================

==== Représentation d'un point dans le standard x509

Un point de la courbe d'abscisse _x_ donnée ne peut avoir que deux valeurs de _y_ (du fait du terme _y^2^_ des équations).

Le standard X9.62 définit la méthode pour désigner quel _y_ est le bon, en utilisant un seul bit d'information. Ainsi l'enregistrement de _x_ et du bit d'information pour retrouver le bon _y_ suffisent à coder un point, et cette forme est dite _compressée_. Comme il est en plus possible de mélanger les formes (compressée et non compressée), un point peut être codé de trois manières{nbsp}:

La forme non compressée::
Enregistrement des deux coordonnées

La forme compressée::
Enregistrement de _x_ et du bit d'information relatif à _y_

La forme hybride::
Enregistrement de _x_, _y_ et du bit d'information relatif à _y_

Sur _F~p~_ on a _y~1~{nbsp}={nbsp}-y~2~_ (car non seulement _y_ y apparaît sous la forme _y^2^_, mais en plus, il est isolé à gauche du signe _égal_) et comme nous sommes dans l'arithmétique modulaire on peut ré-écrire cette égalité _y~1~{nbsp}{plus}{nbsp}y~2~{nbsp}={nbsp}p_.
_p_ étant impair, _y~1~_ et _y~2~_ n'ont pas même parité. Le bit d'information est le dernier bit de _y_ (sa parité). On comprend aisément que la forme hybride ne présente aucun intérêt sur _F~p~_, puisqu'un simple examen de _y_ donne le bit d'information à employer dans la forme compressée. La forme hybride apporte un plus sur _F~2^m^~_ où le bit d'information doit être calculé.

Le standard x509 (ici la RFC 5480) permet de coder un point soit sous forme compressée, soit sous forme non compressée. La RFC 5480 interdit expressément la forme hybride définie par le standard X9.62.

Selon le standard X9.62 en vigueur dans la RFC 5480 (nous ne mentionnons donc pas ici la forme hybride, interdite par la RFC 5480) les formes compressée et non compressée sont codées ainsifootnote:[Le standard X9.62 définit _00_ comme seul octet pour coder le point à l'infini. La RFC 5480 interdit toute autre valeur que _02_, _03_ et _04_, et interdit donc _00_. C'est logique car on ne voit pas dans quel but le point à l'infini serait enregistré dans le cadre x509. Dans le standard x509, un point est une clé publique.]{nbsp}:

* Premier octet = _02_{nbsp}: le point est compressé, et _y_ est pair. _x_ est codé juste après 02.
* Premier octet = _03_{nbsp}: le point est compressé, et _y_ est impair. _x_ est codé juste après 03.
* Premier octet = _04_{nbsp}: le point est non compressé. _x_ est codé juste après 04, et _y_ est codé juste après _x_. Comme _x_ et _y_ ont même taille, il n'y a pas besoin de délimiteur pour retrouver la position à laquelle on passe de _x_ à _y_.

==== La courbe prime256v1 (secp256r1)

.Les paramètres de la courbe prime256v1

Récupérons les paramètres (depuis _openssl_ ou depuis ce document{nbsp}<<18>>) de la courbe et enregistrons-les dans le fichier _secp256r1.b_.

Pour représenter un point de la courbe nous utilisons la convention _point[0] = abscisse du point_ et _point[1] = ordonnée du point_. Le point à l'infini est représenté par _point[2] = 1_ (_point[2] = 0_ pour tout autre point).

.secp256r1.b
[source, bc]
----
include::secp256r1.b[]
----

Au passage, on peut vérifier que le point _G_ fait bien partie de la courbe{nbsp}:

[caption="Fig. 32", title=" "]
image::img-verif-prime256v1-redim.png["Vérification prime256v1"]

On peut également vérifier que _nG{nbsp}={nbsp}O_, _O_ étant le point à l'infini.
Dans la convention des fonctions de _crypto.b_, le point à l'infini est codé par une valeur non nulle de l'élément d'indice _2_{nbsp}:

[caption="Fig. 33", title=" "]
image::img-n_fois_g-redim.png["n fois G"]

.Création d'une paire de clé privée et publique sur prime256v1

Exécuter footnote:[Enregistrer une clé privée dans un fichier non protégé par mot de passe (chiffré) est une mauvaise pratique. Ici cela n'a pas d'importance puisque la clé est une clé de test.]

 $ openssl ecparam -name prime256v1 -genkey -out k.pem

Examiner le résultat avec

 $ openssl ec -in k.pem -noout -text

[caption="Fig. 34", title=" "]
image::img-key-redim.png["ECC key"]

Par défaut, _openssl_ enregistre les clés publiques sous forme non compressée, ce que l'on peut voir au _04_ qui démarre la suite d'octets en-dessous de "pub:".

À l'aide de la commande _openssl_ ci-dessus (ou bien avec _pkfile_, ou encore _dder_), copier/coller les valeurs de la clé privée et publique dans _k.b_, sous les noms _k_ et _q[]_, respectivement.

.k.b
[source, bc]
----
include::k.b[]
----

.Calcul de la clé publique d'après la clé privée

On peut facilement calculer _Q_ (la clé publique) d'après _k_ (la clé privée). Au passage, cela permet de vérifier le bon fonctionnement de la chaîne{nbsp}:

. Les fonctions de _crypto.b_
. Les paramètres de domaine de _prime256v1_
. La définition dans _k.b_ des valeurs de la paire de clés privée et publique

[caption="Fig. 35", title=" "]
image::img-k_fois_g-redim.png["k fois G"]

== Bibliography

* *[[[1]]]* Présentation de l'ASN.1{nbsp}: http://www.itu.int/en/ITU-T/asn1/Pages/introduction.aspx
* *[[[2]]]* Document X.690 (format PDF){nbsp}: https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
* *[[[3]]]* Article Wikipédia consacré au X.690{nbsp}: https://en.wikipedia.org/wiki/X.690
* *[[[4]]]* RFC 5280 (certificats x509 v3){nbsp}: https://tools.ietf.org/html/rfc5280
* *[[[5]]]* Article Wikipédia consacré au RSA{nbsp}: https://fr.wikipedia.org/wiki/Chiffrement_RSA
* *[[[6]]]* Page d'accueil de _bc_{nbsp}: https://www.gnu.org/software/bc/
* *[[[7]]]* _bc_ pour Windows{nbsp}: http://gnuwin32.sourceforge.net/packages/bc.htm
+
_bc_ a besoin du fichier _readline5.dll_ pour s'exécuter. Vous pouvez le trouver à cette URL{nbsp}: http://gnuwin32.sourceforge.net/packages/readline.htm

* *[[[8]]]* Le site de notepad++ {nbsp}: https://notepad-plus-plus.org/fr
* *[[[9]]]* Article Wikipédia sur l'algorithme d'exponentiation rapide{nbsp}: https://fr.wikipedia.org/wiki/Exponentiation_rapide
* *[[[10]]]* Article Wikipédia sur l'exponentiation modulaire{nbsp}: https://fr.wikipedia.org/wiki/Exponentiation_modulaire
* *[[[11]]]* Obtenir _dder_{nbsp}: http://dder.sourceforge.net
* *[[[12]]]* Obtenir _pkfile_{nbsp}: http://pkfile.sourceforge.net
* *[[[13]]]* GNUWin32{nbsp}: http://gnuwin32.sourceforge.net/packages/openssl.htm
* *[[[14]]]* Télécharger 7-ZIP{nbsp}: http://www.7-zip.org/download.html
* *[[[15]]]* Peter Seibt, Andreea Dragut Cours de cryptographie Chapitre V (format PDF){nbsp}: http://www.dil.univ-mrs.fr/~jfp/master/m03/CompresChap5AES.pdf
* *[[[16]]]* An introduction to elliptic curve cryptography{nbsp}: http://www.embedded.com/design/safety-and-security/4396040/An-Introduction-to-Elliptic-Curve-Cryptography
* *[[[17]]]* Corps finis (format PDF){nbsp}: http://iml.univ-mrs.fr/~rodier/Cours/RappelCorps%20finis.pdf
* *[[[18]]]* SEC 2: Recommended Elliptic Curve Domain Parameters (format PDF){nbsp}: http://www.secg.org/SEC2-Ver-1.0.pdf
* *[[[19]]]* RECOMMENDED ELLIPTIC CURVES FOR FEDERAL GOVERNMENT USE (format PDF){nbsp}: http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf
* *[[[20]]]* Elliptic Curve Cryptography Subject Public Key Information{nbsp}: https://tools.ietf.org/html/rfc5480
* *[[[21]]]* "Courbe elliptique" sur Wikipédia{nbsp}: https://fr.wikipedia.org/wiki/Courbe_elliptique#Additionner_les_points_:_d.C3.A9finition_par_la_m.C3.A9thode_des_tangentes_et_des_s.C3.A9cantes
* *[[[22]]]* Article Wikipédia sur l'inverse modulaire{nbsp}: https://fr.wikipedia.org/wiki/Inverse_modulaire
* *[[[23]]]* Conception d'algorithmes et applications (LI325) COURS 10 (format PDF){nbsp}: http://www.di.ens.fr/~busic/cours/LI325/coursCAAC10.pdf

* *[[[99]]]* ECC Tutorial (en anglais){nbsp}: http://www.johannes-bauer.com/compsci/ecc
* *[[[98]]]* Paramètres de domain brainpool (format PDF){nbsp}: http://www.ecc-brainpool.org/download/Domain-parameters.pdf

